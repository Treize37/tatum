=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module SwaggerClient
  class BlockchainMultiTokenERC1155Api
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add Multi Token miter
    # <h4>2 credits per API call.</h4><br/> <p>Add Multi Token minter.<br/><br/> Tatum now supports Multi Tokens these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def add_multi_token_minter(body, opts = {})
      data, _status_code, _headers = add_multi_token_minter_with_http_info(body, opts)
      data
    end

    # Add Multi Token miter
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Add Multi Token minter.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Tokens these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def add_multi_token_minter_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.add_multi_token_minter ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.add_multi_token_minter"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/mint/add'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#add_multi_token_minter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Burn Multi Token
    # <h4>2 credits per API call.</h4><br/> <p>Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress.<br/><br/> Tatum now supports Multi Token these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (Matic)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> <li><b>Algorand</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def burn_multi_token(body, opts = {})
      data, _status_code, _headers = burn_multi_token_with_http_info(body, opts)
      data
    end

    # Burn Multi Token
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Token these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Algorand&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def burn_multi_token_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.burn_multi_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.burn_multi_token"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/burn'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#burn_multi_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Burn Multi Token Batch
    # <h4>2 credits per API call.</h4><br/> <p>Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress.<br/><br/> Tatum now supports Multi Tokens these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def burn_multi_token_batch(body, opts = {})
      data, _status_code, _headers = burn_multi_token_batch_with_http_info(body, opts)
      data
    end

    # Burn Multi Token Batch
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Tokens these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def burn_multi_token_batch_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.burn_multi_token_batch ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.burn_multi_token_batch"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/burn/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#burn_multi_token_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy Multi Token Smart Contract.
    # <p>Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once.<br/> Tatum now supports Multi Tokens on these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> </ul>  This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def deploy_multi_token(body, opts = {})
      data, _status_code, _headers = deploy_multi_token_with_http_info(body, opts)
      data
    end

    # Deploy Multi Token Smart Contract.
    # &lt;p&gt;Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once.&lt;br/&gt; Tatum now supports Multi Tokens on these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;  This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def deploy_multi_token_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.deploy_multi_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.deploy_multi_token"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#deploy_multi_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Mint Multi Token
    # <h4>2 credits per API call.</h4><br/> <p>Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about it.<br/><br/> Tatum now supports Multi Token these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> <li><b>Algorand</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def mint_multi_token(body, opts = {})
      data, _status_code, _headers = mint_multi_token_with_http_info(body, opts)
      data
    end

    # Mint Multi Token
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about it.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Token these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Algorand&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def mint_multi_token_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.mint_multi_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.mint_multi_token"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/mint'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#mint_multi_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Mint Multi Token Batch
    # <h4>2 credits per API call.</h4><br/> <p>Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress.<br/><br/> Tatum now supports Multi Tokens on these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def mint_multi_token_batch(body, opts = {})
      data, _status_code, _headers = mint_multi_token_batch_with_http_info(body, opts)
      data
    end

    # Mint Multi Token Batch
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Tokens on these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def mint_multi_token_batch_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.mint_multi_token_batch ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.mint_multi_token_batch"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/mint/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#mint_multi_token_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Multi Tokens by Address
    # <h4>1 credit per API call.</h4><br/><p>Get Multi Tokens on address. Returns all tokenIDs of all contracts this address holds.</p> 
    # @param chain Blockchain to work with
    # @param address Blockchain address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [Array<InlineResponse20046>]
    def multi_token_get_address_balance(chain, address, opts = {})
      data, _status_code, _headers = multi_token_get_address_balance_with_http_info(chain, address, opts)
      data
    end

    # Get Multi Tokens by Address
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Multi Tokens on address. Returns all tokenIDs of all contracts this address holds.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param address Blockchain address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(Array<InlineResponse20046>, Integer, Hash)>] Array<InlineResponse20046> data, response status code and response headers
    def multi_token_get_address_balance_with_http_info(chain, address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_address_balance ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_address_balance"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'CELO'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, CELO"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_address_balance"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten'
      end
      # resource path
      local_var_path = '/v3/multitoken/address/balance/{chain}/{address}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<InlineResponse20046>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_address_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Multi Token Account balance
    # <h4>1 credit per API call.</h4><br/><p>Get Multi Tokens on Account. Returns tokenIDs of tokens Account holds.</p> 
    # @param chain Blockchain to work with
    # @param address Account address
    # @param contract_address Multi Token contract address
    # @param token_id Multi Token tokenID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [Array<String>]
    def multi_token_get_balance(chain, address, contract_address, token_id, opts = {})
      data, _status_code, _headers = multi_token_get_balance_with_http_info(chain, address, contract_address, token_id, opts)
      data
    end

    # Get Multi Token Account balance
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Multi Tokens on Account. Returns tokenIDs of tokens Account holds.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param address Account address
    # @param contract_address Multi Token contract address
    # @param token_id Multi Token tokenID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(Array<String>, Integer, Hash)>] Array<String> data, response status code and response headers
    def multi_token_get_balance_with_http_info(chain, address, contract_address, token_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_balance ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, BSC"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance"
      end
      # verify the required parameter 'token_id' is set
      if @api_client.config.client_side_validation && token_id.nil?
        fail ArgumentError, "Missing the required parameter 'token_id' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/balance/{chain}/{contractAddress}/{address}/{tokenId}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s).sub('{' + 'tokenId' + '}', token_id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<String>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Multi Token Account balance Batch
    # <h4>1 credit per API call.</h4><br/><p>Get Multi Tokens on Account. Returns tokenIDs of tokens Account holds.</p> 
    # @param chain Blockchain to work with
    # @param contract_address Multi Token contract address
    # @param token_id Comma separated TokenIds to get balance for
    # @param address Comma separated addresses to get balance for
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [Array<String>]
    def multi_token_get_balance_batch(chain, contract_address, token_id, address, opts = {})
      data, _status_code, _headers = multi_token_get_balance_batch_with_http_info(chain, contract_address, token_id, address, opts)
      data
    end

    # Get Multi Token Account balance Batch
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Multi Tokens on Account. Returns tokenIDs of tokens Account holds.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param contract_address Multi Token contract address
    # @param token_id Comma separated TokenIds to get balance for
    # @param address Comma separated addresses to get balance for
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(Array<String>, Integer, Hash)>] Array<String> data, response status code and response headers
    def multi_token_get_balance_batch_with_http_info(chain, contract_address, token_id, address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_balance_batch ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance_batch"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance_batch"
      end
      # verify the required parameter 'token_id' is set
      if @api_client.config.client_side_validation && token_id.nil?
        fail ArgumentError, "Missing the required parameter 'token_id' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance_batch"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_balance_batch"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/balance/batch/{chain}/{contractAddress}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'tokenId'] = token_id
      query_params[:'address'] = address

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<String>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_balance_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Contract address
    # <h4>1 credit per API call.</h4><br/> <p>Get Multi Token contract address from deploy transaction. This method is deprecated, use <a href=\"#operation/SCGetContractAddress\">Get contract address</a> instead.</p> 
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20044]
    def multi_token_get_contract_address(chain, hash, opts = {})
      data, _status_code, _headers = multi_token_get_contract_address_with_http_info(chain, hash, opts)
      data
    end

    # Get Contract address
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Get Multi Token contract address from deploy transaction. This method is deprecated, use &lt;a href&#x3D;\&quot;#operation/SCGetContractAddress\&quot;&gt;Get contract address&lt;/a&gt; instead.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20044, Integer, Hash)>] InlineResponse20044 data, response status code and response headers
    def multi_token_get_contract_address_with_http_info(chain, hash, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_contract_address ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_contract_address"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, BSC"
      end
      # verify the required parameter 'hash' is set
      if @api_client.config.client_side_validation && hash.nil?
        fail ArgumentError, "Missing the required parameter 'hash' when calling BlockchainMultiTokenERC1155Api.multi_token_get_contract_address"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/address/{chain}/{hash}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'hash' + '}', hash.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20044' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_contract_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Multi Token Token Metadata
    # <h4>1 credit per API call.</h4><br/><p>Get Multi Token metadata.</p>
    # @param chain Blockchain to work with
    # @param token Token ID
    # @param contract_address Multi Token contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20041]
    def multi_token_get_metadata(chain, token, contract_address, opts = {})
      data, _status_code, _headers = multi_token_get_metadata_with_http_info(chain, token, contract_address, opts)
      data
    end

    # Get Multi Token Token Metadata
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Multi Token metadata.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param token Token ID
    # @param contract_address Multi Token contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20041, Integer, Hash)>] InlineResponse20041 data, response status code and response headers
    def multi_token_get_metadata_with_http_info(chain, token, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_metadata ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_metadata"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, BSC"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling BlockchainMultiTokenERC1155Api.multi_token_get_metadata"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_metadata"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/metadata/{chain}/{contractAddress}/{token}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'token' + '}', token.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20041' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_metadata\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Transaction
    # <h4>1 credit per API call.</h4><br/><p>Get Multi Token transaction by transaction hash.</p>
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20045]
    def multi_token_get_transaction(chain, hash, opts = {})
      data, _status_code, _headers = multi_token_get_transaction_with_http_info(chain, hash, opts)
      data
    end

    # Get Transaction
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Multi Token transaction by transaction hash.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20045, Integer, Hash)>] InlineResponse20045 data, response status code and response headers
    def multi_token_get_transaction_with_http_info(chain, hash, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_transaction ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_transaction"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, BSC"
      end
      # verify the required parameter 'hash' is set
      if @api_client.config.client_side_validation && hash.nil?
        fail ArgumentError, "Missing the required parameter 'hash' when calling BlockchainMultiTokenERC1155Api.multi_token_get_transaction"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/transaction/{chain}/{hash}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'hash' + '}', hash.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20045' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Multi Token transactions by address
    # <h4>1 credit per API call.</h4><br/><p>Get Multi Token (ERC-1155) transactions by address. This includes incoming and outgoing transactions for the address.</p>
    # @param chain Blockchain to work with
    # @param address Account address
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @return [Array<null>]
    def multi_token_get_transaction_by_address(chain, address, token_address, page_size, opts = {})
      data, _status_code, _headers = multi_token_get_transaction_by_address_with_http_info(chain, address, token_address, page_size, opts)
      data
    end

    # Get Multi Token transactions by address
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Multi Token (ERC-1155) transactions by address. This includes incoming and outgoing transactions for the address.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param address Account address
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @return [Array<(Array<null>, Integer, Hash)>] Array<null> data, response status code and response headers
    def multi_token_get_transaction_by_address_with_http_info(chain, address, token_address, page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.multi_token_get_transaction_by_address ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMultiTokenERC1155Api.multi_token_get_transaction_by_address"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['CELO', 'ETH', 'MATIC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of CELO, ETH, MATIC"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_transaction_by_address"
      end
      # verify the required parameter 'token_address' is set
      if @api_client.config.client_side_validation && token_address.nil?
        fail ArgumentError, "Missing the required parameter 'token_address' when calling BlockchainMultiTokenERC1155Api.multi_token_get_transaction_by_address"
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling BlockchainMultiTokenERC1155Api.multi_token_get_transaction_by_address"
      end
      # resource path
      local_var_path = '/v3/multitoken/transaction/{chain}/{address}/{tokenAddress}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s).sub('{' + 'tokenAddress' + '}', token_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'from'] = opts[:'from'] if !opts[:'from'].nil?
      query_params[:'to'] = opts[:'to'] if !opts[:'to'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<null>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#multi_token_get_transaction_by_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Transfer Multi Token Token
    # <h4>2 credits per API call.</h4><br/> <p>Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transfered. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.<br/><br/> Tatum now supports Multi Token these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> <li><b>Algorand</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def transfer_multi_token(body, opts = {})
      data, _status_code, _headers = transfer_multi_token_with_http_info(body, opts)
      data
    end

    # Transfer Multi Token Token
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transfered. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Token these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Algorand&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def transfer_multi_token_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.transfer_multi_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.transfer_multi_token"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/transaction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#transfer_multi_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Transfer Multi Token Batch
    # <h4>2 credits per API call.</h4><br/> <p>Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transfered. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.<br/><br/> Tatum now supports Multi Tokens these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def transfer_multi_token_batch(body, opts = {})
      data, _status_code, _headers = transfer_multi_token_batch_with_http_info(body, opts)
      data
    end

    # Transfer Multi Token Batch
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transfered. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.&lt;br/&gt;&lt;br/&gt; Tatum now supports Multi Tokens these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def transfer_multi_token_batch_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMultiTokenERC1155Api.transfer_multi_token_batch ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMultiTokenERC1155Api.transfer_multi_token_batch"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/multitoken/transaction/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMultiTokenERC1155Api#transfer_multi_token_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
