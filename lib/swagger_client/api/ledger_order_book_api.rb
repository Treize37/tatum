=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module SwaggerClient
  class LedgerOrderBookApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Obtain chart data from historical closed trades
    # <h4>2 credits for API call.</h4><br/> <p>Obtain data from the closed trades for entering in the chart. Time interval is set between <i>from</i> and <i>to</i> and there is defined time frame. There can be obtained at most 200 time points in the time interval.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<Chart>]
    def chart_request(body, opts = {})
      data, _status_code, _headers = chart_request_with_http_info(body, opts)
      data
    end

    # Obtain chart data from historical closed trades
    # &lt;h4&gt;2 credits for API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Obtain data from the closed trades for entering in the chart. Time interval is set between &lt;i&gt;from&lt;/i&gt; and &lt;i&gt;to&lt;/i&gt; and there is defined time frame. There can be obtained at most 200 time points in the time interval.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Chart>, Integer, Hash)>] Array<Chart> data, response status code and response headers
    def chart_request_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.chart_request ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling LedgerOrderBookApi.chart_request"
      end
      # resource path
      local_var_path = '/v3/trade/chart'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Array<Chart>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#chart_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Cancel all existing trades for account
    # <h4>1 credit for API call, 1 credit for each cancelled trade. 1 API call + 2 cancellations  = 3 credits.</h4><br/><p>Cancel all trades for account.</p>
    # @param id Account ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_account_trades(id, opts = {})
      delete_account_trades_with_http_info(id, opts)
      nil
    end

    # Cancel all existing trades for account
    # &lt;h4&gt;1 credit for API call, 1 credit for each cancelled trade. 1 API call + 2 cancellations  &#x3D; 3 credits.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Cancel all trades for account.&lt;/p&gt;
    # @param id Account ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_account_trades_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.delete_account_trades ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling LedgerOrderBookApi.delete_account_trades"
      end
      # resource path
      local_var_path = '/v3/trade/account/{id}'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#delete_account_trades\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Cancel existing trade
    # <h4>1 credit for API call</h4><br/><p>Cancel existing trade.</p>
    # @param id Trade ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_trade(id, opts = {})
      delete_trade_with_http_info(id, opts)
      nil
    end

    # Cancel existing trade
    # &lt;h4&gt;1 credit for API call&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Cancel existing trade.&lt;/p&gt;
    # @param id Trade ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_trade_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.delete_trade ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling LedgerOrderBookApi.delete_trade"
      end
      # resource path
      local_var_path = '/v3/trade/{id}'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#delete_trade\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all active buy trades
    # <h4>1 credit per API call.</h4><br/><p>List all active buy trades.</p>
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Account ID. If present, list current active buy trades for that account.
    # @option opts [String] :customer_id Customer ID. If present, list current active buy trades for that customer.
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [String] :pair Trade pair. If present, list current active buy trades for that pair.
    # @option opts [BOOLEAN] :count Get the total trade pair count based on the filter. Either count or pageSize is accepted.
    # @option opts [String] :trade_type Trade type.
    # @return [Array<Trade>]
    def get_buy_trades(page_size, opts = {})
      data, _status_code, _headers = get_buy_trades_with_http_info(page_size, opts)
      data
    end

    # List all active buy trades
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all active buy trades.&lt;/p&gt;
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Account ID. If present, list current active buy trades for that account.
    # @option opts [String] :customer_id Customer ID. If present, list current active buy trades for that customer.
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [String] :pair Trade pair. If present, list current active buy trades for that pair.
    # @option opts [BOOLEAN] :count Get the total trade pair count based on the filter. Either count or pageSize is accepted.
    # @option opts [String] :trade_type Trade type.
    # @return [Array<(Array<Trade>, Integer, Hash)>] Array<Trade> data, response status code and response headers
    def get_buy_trades_with_http_info(page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_buy_trades ...'
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling LedgerOrderBookApi.get_buy_trades"
      end
      if @api_client.config.client_side_validation && opts[:'trade_type'] && !['FUTURE_BUY', 'BUY'].include?(opts[:'trade_type'])
        fail ArgumentError, 'invalid value for "trade_type", must be one of FUTURE_BUY, BUY'
      end
      # resource path
      local_var_path = '/v3/trade/buy'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'customerId'] = opts[:'customer_id'] if !opts[:'customer_id'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'pair'] = opts[:'pair'] if !opts[:'pair'].nil?
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'tradeType'] = opts[:'trade_type'] if !opts[:'trade_type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<Trade>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_buy_trades\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all active buy trades
    # <h4>1 credit per API call.</h4><br/><p>List all active buy trades.</p>
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<Trade>]
    def get_buy_trades_body(body, opts = {})
      data, _status_code, _headers = get_buy_trades_body_with_http_info(body, opts)
      data
    end

    # List all active buy trades
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all active buy trades.&lt;/p&gt;
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Trade>, Integer, Hash)>] Array<Trade> data, response status code and response headers
    def get_buy_trades_body_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_buy_trades_body ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling LedgerOrderBookApi.get_buy_trades_body"
      end
      # resource path
      local_var_path = '/v3/trade/buy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Array<Trade>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_buy_trades_body\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all historical trades
    # <h4>1 credit per API call.</h4><br/><p>List all historical trades. It is possible to list all trades, trades for specific trading pair and/or account.</p>
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Account ID. If present, only closed trades for given account will be present.
    # @option opts [String] :pair Trade pair. If present, only closed trades on given trade pair will be present.
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BOOLEAN] :count Get the total trade pair count based on the filter. Either count or pageSize is accepted.
    # @option opts [Array<String>] :types Trade types.
    # @return [Array<Trade>]
    def get_historical_trades(page_size, opts = {})
      data, _status_code, _headers = get_historical_trades_with_http_info(page_size, opts)
      data
    end

    # List all historical trades
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all historical trades. It is possible to list all trades, trades for specific trading pair and/or account.&lt;/p&gt;
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Account ID. If present, only closed trades for given account will be present.
    # @option opts [String] :pair Trade pair. If present, only closed trades on given trade pair will be present.
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BOOLEAN] :count Get the total trade pair count based on the filter. Either count or pageSize is accepted.
    # @option opts [Array<String>] :types Trade types.
    # @return [Array<(Array<Trade>, Integer, Hash)>] Array<Trade> data, response status code and response headers
    def get_historical_trades_with_http_info(page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_historical_trades ...'
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling LedgerOrderBookApi.get_historical_trades"
      end
      if @api_client.config.client_side_validation && opts[:'types'] && !opts[:'types'].all? { |item| ['FUTURE_BUY', 'FUTURE_SELL', 'BUY', 'SELL'].include?(item) }
        fail ArgumentError, 'invalid value for "types", must include one of FUTURE_BUY, FUTURE_SELL, BUY, SELL'
      end
      # resource path
      local_var_path = '/v3/trade/history'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'pair'] = opts[:'pair'] if !opts[:'pair'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'types'] = @api_client.build_collection_param(opts[:'types'], :multi) if !opts[:'types'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<Trade>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_historical_trades\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all historical trades
    # <h4>1 credit per API call.</h4><br/><p>List all historical trades. It is possible to list all trades, trades for specific trading pair and/or account.</p>
    # @param [Hash] opts the optional parameters
    # @option opts [ListOderBookHistoryBody] :body 
    # @return [Array<Trade>]
    def get_historical_trades_body(opts = {})
      data, _status_code, _headers = get_historical_trades_body_with_http_info(opts)
      data
    end

    # List all historical trades
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all historical trades. It is possible to list all trades, trades for specific trading pair and/or account.&lt;/p&gt;
    # @param [Hash] opts the optional parameters
    # @option opts [ListOderBookHistoryBody] :body 
    # @return [Array<(Array<Trade>, Integer, Hash)>] Array<Trade> data, response status code and response headers
    def get_historical_trades_body_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_historical_trades_body ...'
      end
      # resource path
      local_var_path = '/v3/trade/history'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(opts[:'body']) 

      return_type = opts[:return_type] || 'Array<Trade>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_historical_trades_body\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all active sell trades
    # <h4>1 credit per API call.</h4><br/><p>List all active sell trades.</p>
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Account ID. If present, list current active sell trades for that account.
    # @option opts [String] :customer_id Customer ID. If present, list current active buy trades for that customer.
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [String] :pair Trade pair. If present, list current active sell trades for that pair.
    # @option opts [BOOLEAN] :count Get the total trade pair count based on the filter. Either count or pageSize is accepted.
    # @option opts [String] :trade_type Trade type.
    # @return [Array<Trade>]
    def get_sell_trades(page_size, opts = {})
      data, _status_code, _headers = get_sell_trades_with_http_info(page_size, opts)
      data
    end

    # List all active sell trades
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all active sell trades.&lt;/p&gt;
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Account ID. If present, list current active sell trades for that account.
    # @option opts [String] :customer_id Customer ID. If present, list current active buy trades for that customer.
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [String] :pair Trade pair. If present, list current active sell trades for that pair.
    # @option opts [BOOLEAN] :count Get the total trade pair count based on the filter. Either count or pageSize is accepted.
    # @option opts [String] :trade_type Trade type.
    # @return [Array<(Array<Trade>, Integer, Hash)>] Array<Trade> data, response status code and response headers
    def get_sell_trades_with_http_info(page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_sell_trades ...'
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling LedgerOrderBookApi.get_sell_trades"
      end
      if @api_client.config.client_side_validation && opts[:'trade_type'] && !['FUTURE_SELL', 'SELL'].include?(opts[:'trade_type'])
        fail ArgumentError, 'invalid value for "trade_type", must be one of FUTURE_SELL, SELL'
      end
      # resource path
      local_var_path = '/v3/trade/sell'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'customerId'] = opts[:'customer_id'] if !opts[:'customer_id'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'pair'] = opts[:'pair'] if !opts[:'pair'].nil?
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'tradeType'] = opts[:'trade_type'] if !opts[:'trade_type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<Trade>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_sell_trades\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all active sell trades
    # <h4>1 credit per API call.</h4><br/><p>List all active sell trades.</p>
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<Trade>]
    def get_sell_trades_body(body, opts = {})
      data, _status_code, _headers = get_sell_trades_body_with_http_info(body, opts)
      data
    end

    # List all active sell trades
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all active sell trades.&lt;/p&gt;
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Trade>, Integer, Hash)>] Array<Trade> data, response status code and response headers
    def get_sell_trades_body_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_sell_trades_body ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling LedgerOrderBookApi.get_sell_trades_body"
      end
      # resource path
      local_var_path = '/v3/trade/sell'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Array<Trade>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_sell_trades_body\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get existing trade
    # <h4>1 credit for API call</h4><br/><p>Get existing opened trade.</p>
    # @param id Trade ID
    # @param [Hash] opts the optional parameters
    # @return [Trade]
    def get_trade_by_id(id, opts = {})
      data, _status_code, _headers = get_trade_by_id_with_http_info(id, opts)
      data
    end

    # Get existing trade
    # &lt;h4&gt;1 credit for API call&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get existing opened trade.&lt;/p&gt;
    # @param id Trade ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Trade, Integer, Hash)>] Trade data, response status code and response headers
    def get_trade_by_id_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.get_trade_by_id ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling LedgerOrderBookApi.get_trade_by_id"
      end
      # resource path
      local_var_path = '/v3/trade/{id}'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Trade' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#get_trade_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Store buy / sell trade
    # <h4>2 credits for API call, 2 credits for each fill of the counter trade. 1 API call + 2 fills  = 6 credits.</h4><br/> <p>Store new buy / sell trade. If there is trade already available to fill, fill as much trades as possible.<br/> It is possible to charge fees for the trades. Fees are an extra amount on top of the trade amount and are paid in the currency of the 1st pair to the separate fee account, e.g. for BTC/ETH pair fees will be paid in BTC.</p>  <p> If you fill type of the trade with FUTURE_BUY or FUTURE_SELL the trade will behave as a trade future. The trade is concluded now but will be fulfilled in future. The date of fulfillment is by the “Seal Date” field. You can also block a percentage of the amount until the future trade has expired. </p> <p>Futures can also penalize contracting parties if they don’t have the agreed balance available in their accounts. The penalty is calculated in the following way: Penalty amount = (Percentage of incomplete deal amount because of shortage from user) × (Maximum Penalty percentage of futures deal based on blocked amount and time interval) × (total blocked value). </p> <p>Example of the BTC/USDT trade future:</p> <p>The maker creates a sell with the following properties: 1 BTC at a price of 60000 USDT, with a blocking percentage of 22%, a penalty percentage of 45%, a system commision of 1% and with an expiration time of within 12 hours.</p> <pre> {   \"type\": \"FUTURE_SELL\",   \"price\": \"60000\",   \"amount\": \"1\",   \"pair\": \"BTC/USDT\",   \"currency1AccountId\": \"60a236db1b57f60d62612bf3\",   \"currency2AccountId\": \"609d0696bf835c241ac2920f\",   \"fee\": 1,   \"feeAccountId\": \"609d0696bf835c251ac2920a\",   \"attr\": {     \"sealDate\": 1621990960631,     \"percentBlock\": 22,     \"percentPenalty\": 45   } } </pre>  The taker accepts the offer with a buy and blocks 13200 USDT (60000 USDT × 0.22) in their account. <pre> {   \"type\": \"FUTURE_BUY\",   \"price\": \"60000\",   \"amount\": \"1\",   \"pair\": \"BTC/USDT\",   \"currency1AccountId\": \"60a236db1b57f60d62612bf2\",   \"currency2AccountId\": \"609d0696bf835c241ac2920a\",   \"attr\": {     \"sealDate\": 1621990960631,     \"percentBlock\": 22,     \"percentPenalty\": 45   } } </pre> <p>At the time of the trade, the maker and taker have the following conditions. The maker has 0.65 BTC (35% deficit) in their account and the taker has 49200 USDT (18% deficit) in their account. </p>  <p> The maker penalty is equal to 0.35 × 0.22 × (0.45 × 1 BTC) = 0.03465 BTC. The taker penalty is equal to 0.18 × 0.22 × (0.45 × 60000 USDT) = 1069.2 USDT. </p> <p> The system commission for the maker is 1 BTC × 1% = 0.01 BTC. The system commission for the taker is 60000 USDT × 1% = 600 USDT. </p> <p> The maker’s assets after deducting penalties and commissions equals 0.65 - 0.03465 - 0.01 = 0.60535 BTC. The taker’s assets after deducting penalties and commissions equals 49200 - 1069.2 - 600 = 47530.8 USDT. </p> <p> The amount received by the maker after the trade is (0.60535 × 60000) + 1069.2 = 37390.2 USDT and the taker receives 0.60535 + 0.03465 = 0.64 BTC. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Id]
    def store_trade(body, opts = {})
      data, _status_code, _headers = store_trade_with_http_info(body, opts)
      data
    end

    # Store buy / sell trade
    # &lt;h4&gt;2 credits for API call, 2 credits for each fill of the counter trade. 1 API call + 2 fills  &#x3D; 6 credits.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Store new buy / sell trade. If there is trade already available to fill, fill as much trades as possible.&lt;br/&gt; It is possible to charge fees for the trades. Fees are an extra amount on top of the trade amount and are paid in the currency of the 1st pair to the separate fee account, e.g. for BTC/ETH pair fees will be paid in BTC.&lt;/p&gt;  &lt;p&gt; If you fill type of the trade with FUTURE_BUY or FUTURE_SELL the trade will behave as a trade future. The trade is concluded now but will be fulfilled in future. The date of fulfillment is by the “Seal Date” field. You can also block a percentage of the amount until the future trade has expired. &lt;/p&gt; &lt;p&gt;Futures can also penalize contracting parties if they don’t have the agreed balance available in their accounts. The penalty is calculated in the following way: Penalty amount &#x3D; (Percentage of incomplete deal amount because of shortage from user) × (Maximum Penalty percentage of futures deal based on blocked amount and time interval) × (total blocked value). &lt;/p&gt; &lt;p&gt;Example of the BTC/USDT trade future:&lt;/p&gt; &lt;p&gt;The maker creates a sell with the following properties: 1 BTC at a price of 60000 USDT, with a blocking percentage of 22%, a penalty percentage of 45%, a system commision of 1% and with an expiration time of within 12 hours.&lt;/p&gt; &lt;pre&gt; {   \&quot;type\&quot;: \&quot;FUTURE_SELL\&quot;,   \&quot;price\&quot;: \&quot;60000\&quot;,   \&quot;amount\&quot;: \&quot;1\&quot;,   \&quot;pair\&quot;: \&quot;BTC/USDT\&quot;,   \&quot;currency1AccountId\&quot;: \&quot;60a236db1b57f60d62612bf3\&quot;,   \&quot;currency2AccountId\&quot;: \&quot;609d0696bf835c241ac2920f\&quot;,   \&quot;fee\&quot;: 1,   \&quot;feeAccountId\&quot;: \&quot;609d0696bf835c251ac2920a\&quot;,   \&quot;attr\&quot;: {     \&quot;sealDate\&quot;: 1621990960631,     \&quot;percentBlock\&quot;: 22,     \&quot;percentPenalty\&quot;: 45   } } &lt;/pre&gt;  The taker accepts the offer with a buy and blocks 13200 USDT (60000 USDT × 0.22) in their account. &lt;pre&gt; {   \&quot;type\&quot;: \&quot;FUTURE_BUY\&quot;,   \&quot;price\&quot;: \&quot;60000\&quot;,   \&quot;amount\&quot;: \&quot;1\&quot;,   \&quot;pair\&quot;: \&quot;BTC/USDT\&quot;,   \&quot;currency1AccountId\&quot;: \&quot;60a236db1b57f60d62612bf2\&quot;,   \&quot;currency2AccountId\&quot;: \&quot;609d0696bf835c241ac2920a\&quot;,   \&quot;attr\&quot;: {     \&quot;sealDate\&quot;: 1621990960631,     \&quot;percentBlock\&quot;: 22,     \&quot;percentPenalty\&quot;: 45   } } &lt;/pre&gt; &lt;p&gt;At the time of the trade, the maker and taker have the following conditions. The maker has 0.65 BTC (35% deficit) in their account and the taker has 49200 USDT (18% deficit) in their account. &lt;/p&gt;  &lt;p&gt; The maker penalty is equal to 0.35 × 0.22 × (0.45 × 1 BTC) &#x3D; 0.03465 BTC. The taker penalty is equal to 0.18 × 0.22 × (0.45 × 60000 USDT) &#x3D; 1069.2 USDT. &lt;/p&gt; &lt;p&gt; The system commission for the maker is 1 BTC × 1% &#x3D; 0.01 BTC. The system commission for the taker is 60000 USDT × 1% &#x3D; 600 USDT. &lt;/p&gt; &lt;p&gt; The maker’s assets after deducting penalties and commissions equals 0.65 - 0.03465 - 0.01 &#x3D; 0.60535 BTC. The taker’s assets after deducting penalties and commissions equals 49200 - 1069.2 - 600 &#x3D; 47530.8 USDT. &lt;/p&gt; &lt;p&gt; The amount received by the maker after the trade is (0.60535 × 60000) + 1069.2 &#x3D; 37390.2 USDT and the taker receives 0.60535 + 0.03465 &#x3D; 0.64 BTC. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Id, Integer, Hash)>] Id data, response status code and response headers
    def store_trade_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LedgerOrderBookApi.store_trade ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling LedgerOrderBookApi.store_trade"
      end
      # resource path
      local_var_path = '/v3/trade'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Id' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LedgerOrderBookApi#store_trade\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
