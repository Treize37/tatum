=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module SwaggerClient
  class OffChainWithdrawalApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Broadcast signed transaction and complete withdrawal
    # <h4>2 credits per API call.</h4><br/> <p>Broadcast signed raw transaction end complete withdrawal associated with it. When broadcast succeeded but it is impossible to complete withdrawal, transaction id of transaction is returned and withdrawal must be completed manually. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [BroadcastResponse]
    def broadcast_blockchain_transaction(body, opts = {})
      data, _status_code, _headers = broadcast_blockchain_transaction_with_http_info(body, opts)
      data
    end

    # Broadcast signed transaction and complete withdrawal
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Broadcast signed raw transaction end complete withdrawal associated with it. When broadcast succeeded but it is impossible to complete withdrawal, transaction id of transaction is returned and withdrawal must be completed manually. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BroadcastResponse, Integer, Hash)>] BroadcastResponse data, response status code and response headers
    def broadcast_blockchain_transaction_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainWithdrawalApi.broadcast_blockchain_transaction ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainWithdrawalApi.broadcast_blockchain_transaction"
      end
      # resource path
      local_var_path = '/v3/offchain/withdrawal/broadcast'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'BroadcastResponse' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainWithdrawalApi#broadcast_blockchain_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Cancel withdrawal
    # <h4>1 credit per API call.</h4><br/> <p>This method is helpful if you need to cancel the withdrawal if the blockchain transaction fails or is not yet processed. This does not cancel already broadcast blockchain transaction, only Tatum internal withdrawal, and the ledger transaction, that was linked to this withdrawal.<br/> By default, the transaction fee is included in the reverted transaction. There are situations, like sending ERC20 on ETH, TRC token on TRON, XLM or XRP based assets, when the fee should not be reverted, because e.g. the fee is in calculated in Ethereum and transaction was in ERC20 currency. In this situation, only the transaction amount should be reverted, not the fee. </p> 
    # @param id ID of created withdrawal
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :revert Defines whether fee should be reverted to account balance as well as amount. Defaults to true. Revert true would be typically used when withdrawal was not broadcast to blockchain. False is used usually for Ethereum based currencies when gas was consumed but transaction was reverted. (default to true)
    # @return [nil]
    def cancel_in_progress_withdrawal(id, opts = {})
      cancel_in_progress_withdrawal_with_http_info(id, opts)
      nil
    end

    # Cancel withdrawal
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is helpful if you need to cancel the withdrawal if the blockchain transaction fails or is not yet processed. This does not cancel already broadcast blockchain transaction, only Tatum internal withdrawal, and the ledger transaction, that was linked to this withdrawal.&lt;br/&gt; By default, the transaction fee is included in the reverted transaction. There are situations, like sending ERC20 on ETH, TRC token on TRON, XLM or XRP based assets, when the fee should not be reverted, because e.g. the fee is in calculated in Ethereum and transaction was in ERC20 currency. In this situation, only the transaction amount should be reverted, not the fee. &lt;/p&gt; 
    # @param id ID of created withdrawal
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :revert Defines whether fee should be reverted to account balance as well as amount. Defaults to true. Revert true would be typically used when withdrawal was not broadcast to blockchain. False is used usually for Ethereum based currencies when gas was consumed but transaction was reverted.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def cancel_in_progress_withdrawal_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainWithdrawalApi.cancel_in_progress_withdrawal ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling OffChainWithdrawalApi.cancel_in_progress_withdrawal"
      end
      # resource path
      local_var_path = '/v3/offchain/withdrawal/{id}'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'revert'] = opts[:'revert'] if !opts[:'revert'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainWithdrawalApi#cancel_in_progress_withdrawal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Complete withdrawal
    # <h4>2 credits per API call.</h4><br/> <p>Invoke complete withdrawal as soon as blockchain transaction ID is available. All other withdrawals for the same currency will be pending unless the last one is processed and marked as completed.</p> 
    # @param id ID of created withdrawal
    # @param tx_id Blockchain transaction ID of created withdrawal
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def complete_withdrawal(id, tx_id, opts = {})
      complete_withdrawal_with_http_info(id, tx_id, opts)
      nil
    end

    # Complete withdrawal
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Invoke complete withdrawal as soon as blockchain transaction ID is available. All other withdrawals for the same currency will be pending unless the last one is processed and marked as completed.&lt;/p&gt; 
    # @param id ID of created withdrawal
    # @param tx_id Blockchain transaction ID of created withdrawal
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def complete_withdrawal_with_http_info(id, tx_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainWithdrawalApi.complete_withdrawal ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling OffChainWithdrawalApi.complete_withdrawal"
      end
      # verify the required parameter 'tx_id' is set
      if @api_client.config.client_side_validation && tx_id.nil?
        fail ArgumentError, "Missing the required parameter 'tx_id' when calling OffChainWithdrawalApi.complete_withdrawal"
      end
      # resource path
      local_var_path = '/v3/offchain/withdrawal/{id}/{txId}'.sub('{' + 'id' + '}', id.to_s).sub('{' + 'txId' + '}', tx_id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainWithdrawalApi#complete_withdrawal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get withdrawals
    # <h4>1 credit per API call.</h4><br/><p>Get withdrawals.</p>
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :currency Currency of the withdrawal
    # @option opts [String] :status Status of the withdrawal
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @return [Array<WithdrawalObject>]
    def get_withdrawals(page_size, opts = {})
      data, _status_code, _headers = get_withdrawals_with_http_info(page_size, opts)
      data
    end

    # Get withdrawals
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get withdrawals.&lt;/p&gt;
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :currency Currency of the withdrawal
    # @option opts [String] :status Status of the withdrawal
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @return [Array<(Array<WithdrawalObject>, Integer, Hash)>] Array<WithdrawalObject> data, response status code and response headers
    def get_withdrawals_with_http_info(page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainWithdrawalApi.get_withdrawals ...'
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling OffChainWithdrawalApi.get_withdrawals"
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['InProgress', 'Done', 'Cancelled'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of InProgress, Done, Cancelled'
      end
      # resource path
      local_var_path = '/v3/offchain/withdrawal'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'currency'] = opts[:'currency'] if !opts[:'currency'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<WithdrawalObject>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainWithdrawalApi#get_withdrawals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Store withdrawal
    # <h4>2 credits per API call.</h4><br/><p> <p>Create a withdrawal from Tatum Ledger account to the blockchain.<br/>   <h4>BTC, LTC, DOGE, BCH</h4>   <p>     When withdrawal from Tatum is executed, all deposits, which are not processed yet are used as an input and     change is moved to pool address 0 of wallet for defined account's xpub. If there are no unspent deposits, only last pool address 0 UTXO is used.     If balance of wallet is not sufficient, it is impossible to perform withdrawal from this account -> funds were transferred to another     linked wallet within system or outside of Tatum visibility.<br/>     For the first time of withdrawal from wallet, there must be some deposit made and funds are obtained from that. Since     there is no withdrawal, there was no transfer to pool address 0 and thus it is not present in vIn. Pool transfer is identified by missing data.address property in response.     When last not cancelled withdrawal is not completed and thus there is no tx id of output transaction given,     we cannot perform next withdrawal.   </p>   <h4>ETH</h4>   <p>     Withdrawal from Tatum can be processed only from 1 account. In Ethereum Blockchain, each address is recognized as an account and only funds from that account can be sent in 1 transaction.     Example: Account A has 0.5 ETH, Account B has 0.3 ETH. Account A is linked to Tatum Account 1, Account B is linked to Tatum Account 2. Tatum Account 1 has balance 0.7 Ethereum and     Tatum Account 2 has 0.1 ETH. Withdrawal from Tatum Account 1 can be at most 0.5 ETH, even though balance in Tatum Private Ledger is 0.7 ETH.     Because of this Ethereum Blockchain limitation, withdrawal request should always contain sourceAddress, from which withdrawal will be made. To get available balances for Ethereum wallet accounts, use hint endpoint.   </p>   <h4>XRP</h4>   <p>     XRP withdrawal can contain DestinationTag except of address, which is placed in attr parameter of withdrawal request. SourceTag of the blockchain transaction should be withdrawal ID for autocomplete purposes of withdrawals.   </p>   <h4>XLM</h4>   <p>     XLM withdrawal can contain memo except of address, which is placed in attr parameter of withdrawal request. XLM blockchain does not have possibility to enter source account information.     It is possible to create memo in format 'destination|source', which is supported way of memo in Tatum and also there is information about the sender account in the blockchain.   </p> <br/> When withdrawal is created, all other withdrawals with the same currency are pending, unless the current one is marked as complete or cancelled.<br/> Tatum ledger transaction is created for every withdrawal request with operation type WITHDRAWAL. The value of the transaction is the withdrawal amount + blockchain fee, which should be paid. In the situation, when there is withdrawal for ERC20, XLM, or XRP based custom assets, the fee is not included in the transaction because it is paid in different assets than the withdrawal itself. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [WithdrawalResponse]
    def store_withdrawal(body, opts = {})
      data, _status_code, _headers = store_withdrawal_with_http_info(body, opts)
      data
    end

    # Store withdrawal
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Create a withdrawal from Tatum Ledger account to the blockchain.&lt;br/&gt;   &lt;h4&gt;BTC, LTC, DOGE, BCH&lt;/h4&gt;   &lt;p&gt;     When withdrawal from Tatum is executed, all deposits, which are not processed yet are used as an input and     change is moved to pool address 0 of wallet for defined account&#x27;s xpub. If there are no unspent deposits, only last pool address 0 UTXO is used.     If balance of wallet is not sufficient, it is impossible to perform withdrawal from this account -&gt; funds were transferred to another     linked wallet within system or outside of Tatum visibility.&lt;br/&gt;     For the first time of withdrawal from wallet, there must be some deposit made and funds are obtained from that. Since     there is no withdrawal, there was no transfer to pool address 0 and thus it is not present in vIn. Pool transfer is identified by missing data.address property in response.     When last not cancelled withdrawal is not completed and thus there is no tx id of output transaction given,     we cannot perform next withdrawal.   &lt;/p&gt;   &lt;h4&gt;ETH&lt;/h4&gt;   &lt;p&gt;     Withdrawal from Tatum can be processed only from 1 account. In Ethereum Blockchain, each address is recognized as an account and only funds from that account can be sent in 1 transaction.     Example: Account A has 0.5 ETH, Account B has 0.3 ETH. Account A is linked to Tatum Account 1, Account B is linked to Tatum Account 2. Tatum Account 1 has balance 0.7 Ethereum and     Tatum Account 2 has 0.1 ETH. Withdrawal from Tatum Account 1 can be at most 0.5 ETH, even though balance in Tatum Private Ledger is 0.7 ETH.     Because of this Ethereum Blockchain limitation, withdrawal request should always contain sourceAddress, from which withdrawal will be made. To get available balances for Ethereum wallet accounts, use hint endpoint.   &lt;/p&gt;   &lt;h4&gt;XRP&lt;/h4&gt;   &lt;p&gt;     XRP withdrawal can contain DestinationTag except of address, which is placed in attr parameter of withdrawal request. SourceTag of the blockchain transaction should be withdrawal ID for autocomplete purposes of withdrawals.   &lt;/p&gt;   &lt;h4&gt;XLM&lt;/h4&gt;   &lt;p&gt;     XLM withdrawal can contain memo except of address, which is placed in attr parameter of withdrawal request. XLM blockchain does not have possibility to enter source account information.     It is possible to create memo in format &#x27;destination|source&#x27;, which is supported way of memo in Tatum and also there is information about the sender account in the blockchain.   &lt;/p&gt; &lt;br/&gt; When withdrawal is created, all other withdrawals with the same currency are pending, unless the current one is marked as complete or cancelled.&lt;br/&gt; Tatum ledger transaction is created for every withdrawal request with operation type WITHDRAWAL. The value of the transaction is the withdrawal amount + blockchain fee, which should be paid. In the situation, when there is withdrawal for ERC20, XLM, or XRP based custom assets, the fee is not included in the transaction because it is paid in different assets than the withdrawal itself. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(WithdrawalResponse, Integer, Hash)>] WithdrawalResponse data, response status code and response headers
    def store_withdrawal_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainWithdrawalApi.store_withdrawal ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainWithdrawalApi.store_withdrawal"
      end
      # resource path
      local_var_path = '/v3/offchain/withdrawal'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'WithdrawalResponse' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainWithdrawalApi#store_withdrawal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
