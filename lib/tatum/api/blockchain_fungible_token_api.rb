=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module Tatum
  class BlockchainFungibleTokenApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Approve spending of ERC20
    # <h4>2 credits per API call.</h4><br/> <p>Approve ERC20 Fungible Tokens to be spendable by someone else. This method allows new address to transfer/burn ERC20 tokens on behalf of the owner. <br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def erc20_approve(body, opts = {})
      data, _status_code, _headers = erc20_approve_with_http_info(body, opts)
      data
    end

    # Approve spending of ERC20
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Approve ERC20 Fungible Tokens to be spendable by someone else. This method allows new address to transfer/burn ERC20 tokens on behalf of the owner. &lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def erc20_approve_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_approve ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainFungibleTokenApi.erc20_approve"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/approve'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_approve\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Burn ERC20
    # <h4>2 credits per API call.</h4><br/> <p>Burn ERC20 Fungible Tokens. This method destroys ERC20 tokens from smart contract defined in contractAddress. <br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def erc20_burn(body, opts = {})
      data, _status_code, _headers = erc20_burn_with_http_info(body, opts)
      data
    end

    # Burn ERC20
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Burn ERC20 Fungible Tokens. This method destroys ERC20 tokens from smart contract defined in contractAddress. &lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def erc20_burn_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_burn ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainFungibleTokenApi.erc20_burn"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/burn'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_burn\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy ERC20 Smart Contract.
    # <p>Deploy ERC20 Smart Contract. This method creates new ERC20 (Fungible Tokens) Smart Contract on the blockchain. Smart contract is standardized and audited. It is possible to mint and burn tokens. It is possible to see the code of the deployed contract <a href=\"https://github.com/tatumio/tatum-middleware/blob/master/src/contracts/token.sol\" target=\"_blank\">here</a>. Whole predefined supply of the tokens will be transferred to the chosen address. <br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def erc20_deploy(body, opts = {})
      data, _status_code, _headers = erc20_deploy_with_http_info(body, opts)
      data
    end

    # Deploy ERC20 Smart Contract.
    # &lt;p&gt;Deploy ERC20 Smart Contract. This method creates new ERC20 (Fungible Tokens) Smart Contract on the blockchain. Smart contract is standardized and audited. It is possible to mint and burn tokens. It is possible to see the code of the deployed contract &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-middleware/blob/master/src/contracts/token.sol\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. Whole predefined supply of the tokens will be transferred to the chosen address. &lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def erc20_deploy_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_deploy ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainFungibleTokenApi.erc20_deploy"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_deploy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get ERC20 Account balance
    # <h4>1 credit per API call.</h4><br/><p>Get ERC20 Account balance. Returns number of tokens Account holds.</p>
    # @param chain Network name
    # @param address Account address
    # @param contract_address ERC20 contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20043]
    def erc20_get_balance(chain, address, contract_address, opts = {})
      data, _status_code, _headers = erc20_get_balance_with_http_info(chain, address, contract_address, opts)
      data
    end

    # Get ERC20 Account balance
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get ERC20 Account balance. Returns number of tokens Account holds.&lt;/p&gt;
    # @param chain Network name
    # @param address Account address
    # @param contract_address ERC20 contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20043, Integer, Hash)>] InlineResponse20043 data, response status code and response headers
    def erc20_get_balance_with_http_info(chain, address, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_get_balance ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainFungibleTokenApi.erc20_get_balance"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainFungibleTokenApi.erc20_get_balance"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainFungibleTokenApi.erc20_get_balance"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/balance/{chain}/{contractAddress}/{address}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20043' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_get_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get ERC20 transactions by address
    # <h4>1 credit per API call.</h4><br/><p>Get ERC20 transactions by address. This includes incoming and outgoing transactions for the address.</p>
    # @param chain Blockchain to work with
    # @param address Account address
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @option opts [String] :sort Sorting of the data. ASC - oldest first, DESC - newest first. (default to DESC)
    # @return [Array<null>]
    def erc20_get_transaction_by_address(chain, address, token_address, page_size, opts = {})
      data, _status_code, _headers = erc20_get_transaction_by_address_with_http_info(chain, address, token_address, page_size, opts)
      data
    end

    # Get ERC20 transactions by address
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get ERC20 transactions by address. This includes incoming and outgoing transactions for the address.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param address Account address
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @option opts [String] :sort Sorting of the data. ASC - oldest first, DESC - newest first.
    # @return [Array<(Array<null>, Integer, Hash)>] Array<null> data, response status code and response headers
    def erc20_get_transaction_by_address_with_http_info(chain, address, token_address, page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_get_transaction_by_address ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainFungibleTokenApi.erc20_get_transaction_by_address"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['CELO'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of CELO"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainFungibleTokenApi.erc20_get_transaction_by_address"
      end
      # verify the required parameter 'token_address' is set
      if @api_client.config.client_side_validation && token_address.nil?
        fail ArgumentError, "Missing the required parameter 'token_address' when calling BlockchainFungibleTokenApi.erc20_get_transaction_by_address"
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling BlockchainFungibleTokenApi.erc20_get_transaction_by_address"
      end
      if @api_client.config.client_side_validation && opts[:'sort'] && !['ASC', 'DESC'].include?(opts[:'sort'])
        fail ArgumentError, 'invalid value for "sort", must be one of ASC, DESC'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/transaction/{chain}/{address}/{tokenAddress}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s).sub('{' + 'tokenAddress' + '}', token_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'from'] = opts[:'from'] if !opts[:'from'].nil?
      query_params[:'to'] = opts[:'to'] if !opts[:'to'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<null>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_get_transaction_by_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Mint ERC20
    # <h4>2 credits per API call.</h4><br/> <p>Create new ERC20 Fungible Tokens and transfer it to destination account. Tokens can be created only if current supply is lower then total supply. Create and transfer any ERC20 tokens from smart contract defined in contractAddress. <br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def erc20_mint(body, opts = {})
      data, _status_code, _headers = erc20_mint_with_http_info(body, opts)
      data
    end

    # Mint ERC20
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create new ERC20 Fungible Tokens and transfer it to destination account. Tokens can be created only if current supply is lower then total supply. Create and transfer any ERC20 tokens from smart contract defined in contractAddress. &lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def erc20_mint_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_mint ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainFungibleTokenApi.erc20_mint"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/mint'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_mint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Transfer ERC20 Token
    # <h4>2 credits per API call.</h4><br/> <p>Transfer ERC20 Fungible Tokens from account to account. Transfer any ERC20 tokens from smart contract defined in contractAddress. This method invokes ERC20 method transfer() to transfer tokens. <br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Algorand is unique a way that the receiving account should be ready before sending the FT(Erc20) asset. To perform this, the receiving account should transfer the FT(Erc20) asset with 0 amount to itself. During the process, it's using the same API as the main transaction: the only difference is that the \"fromPrivateKey\" should be the privateKey of the receiving account. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def erc20_transfer(body, opts = {})
      data, _status_code, _headers = erc20_transfer_with_http_info(body, opts)
      data
    end

    # Transfer ERC20 Token
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Transfer ERC20 Fungible Tokens from account to account. Transfer any ERC20 tokens from smart contract defined in contractAddress. This method invokes ERC20 method transfer() to transfer tokens. &lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Algorand is unique a way that the receiving account should be ready before sending the FT(Erc20) asset. To perform this, the receiving account should transfer the FT(Erc20) asset with 0 amount to itself. During the process, it&#x27;s using the same API as the main transaction: the only difference is that the \&quot;fromPrivateKey\&quot; should be the privateKey of the receiving account. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def erc20_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainFungibleTokenApi.erc20_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainFungibleTokenApi.erc20_transfer"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/blockchain/token/transaction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainFungibleTokenApi#erc20_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
