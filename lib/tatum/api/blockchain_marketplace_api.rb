=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module Tatum
  class BlockchainMarketplaceApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Approve NFT token spending for the Auction / Marketplace
    # <h4>2 credits per API call.</h4><br/> <p>Approve NFT transfer for auction to perform listing of the asset.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def approve_nft_auction_spending(body, opts = {})
      data, _status_code, _headers = approve_nft_auction_spending_with_http_info(body, opts)
      data
    end

    # Approve NFT token spending for the Auction / Marketplace
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Approve NFT transfer for auction to perform listing of the asset.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def approve_nft_auction_spending_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.approve_nft_auction_spending ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.approve_nft_auction_spending"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/approve'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#approve_nft_auction_spending\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Bid for asset on the NFT Auction
    # <h4>2 credits per API call.</h4><br/> <p>Bid on the auction. Buyer must either send native assets with this operation, or approve ERC20 token spending before using <a href=\"#operation/Erc20Approve\">Approve ERC20</a>   After auction is sold, it's in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def bid_on_auction(body, opts = {})
      data, _status_code, _headers = bid_on_auction_with_http_info(body, opts)
      data
    end

    # Bid for asset on the NFT Auction
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Bid on the auction. Buyer must either send native assets with this operation, or approve ERC20 token spending before using &lt;a href&#x3D;\&quot;#operation/Erc20Approve\&quot;&gt;Approve ERC20&lt;/a&gt;   After auction is sold, it&#x27;s in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def bid_on_auction_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.bid_on_auction ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.bid_on_auction"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/bid'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#bid_on_auction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Buy asset on the NFT Marketplace
    # <h4>2 credits per API call.</h4><br/> <p>Buy listing on the marketplace. Buyer must either send native assets with this operation, or approve ERC20 token spending before using <a href=\"#operation/Erc20Approve\">Approve spending for marketplace.</a><br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def buy_asset_on_marketplace(body, opts = {})
      data, _status_code, _headers = buy_asset_on_marketplace_with_http_info(body, opts)
      data
    end

    # Buy asset on the NFT Marketplace
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Buy listing on the marketplace. Buyer must either send native assets with this operation, or approve ERC20 token spending before using &lt;a href&#x3D;\&quot;#operation/Erc20Approve\&quot;&gt;Approve spending for marketplace.&lt;/a&gt;&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def buy_asset_on_marketplace_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.buy_asset_on_marketplace ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.buy_asset_on_marketplace"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/buy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#buy_asset_on_marketplace\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Cancel auction of the asset on the NFT Auction
    # <h4>2 credits per API call.</h4><br/> <p>Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def cancel_auction(body, opts = {})
      data, _status_code, _headers = cancel_auction_with_http_info(body, opts)
      data
    end

    # Cancel auction of the asset on the NFT Auction
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def cancel_auction_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.cancel_auction ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.cancel_auction"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/cancel'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#cancel_auction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Cancel selling of the asset on the NFT Marketplace
    # <h4>2 credits per API call.</h4><br/> <p>Cancel listing on the marketplace. Only possible for the seller or the operator. There must be no buyer present for that listing. NFT asset is sent back to the seller.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def cancel_sell_marketplace_listing(body, opts = {})
      data, _status_code, _headers = cancel_sell_marketplace_listing_with_http_info(body, opts)
      data
    end

    # Cancel selling of the asset on the NFT Marketplace
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Cancel listing on the marketplace. Only possible for the seller or the operator. There must be no buyer present for that listing. NFT asset is sent back to the seller.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def cancel_sell_marketplace_listing_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.cancel_sell_marketplace_listing ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.cancel_sell_marketplace_listing"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/cancel'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#cancel_sell_marketplace_listing\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Sell asset on the NFT Auction
    # <h4>2 credits per API call.</h4><br/> <p>Create new auction on the auction contract. Before operation, seller must approve spending of the NFT token for the Auction contract using <a href=\"#operation/ApproveNftAuctionSpending\">Approve NFT</a>. After auction is created, auction contract transfers the asset to the auction smart contract. Only auction for existing NFTs can be created - seller must be owner of the NFT asset.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def create_auction(body, opts = {})
      data, _status_code, _headers = create_auction_with_http_info(body, opts)
      data
    end

    # Sell asset on the NFT Auction
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create new auction on the auction contract. Before operation, seller must approve spending of the NFT token for the Auction contract using &lt;a href&#x3D;\&quot;#operation/ApproveNftAuctionSpending\&quot;&gt;Approve NFT&lt;/a&gt;. After auction is created, auction contract transfers the asset to the auction smart contract. Only auction for existing NFTs can be created - seller must be owner of the NFT asset.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def create_auction_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.create_auction ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.create_auction"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/sell'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#create_auction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create NFT Auction
    # <h4>2 credits per API call.</h4><br/> <p>Deploy new smart contract for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155). Operator can set a fee in percentage, which will be paid on top of the price of the asset. can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation. Before auction is created, seller must approve transfer of the NFT to the auction contract. Buyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token. Buyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called. Once there is higher bid then the actual one, the previous bidder's funds will be returned to him and new bidder will be the current winning one. When auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.<br/> This operation deploys a smart contract on the blockchain.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def generate_auction(body, opts = {})
      data, _status_code, _headers = generate_auction_with_http_info(body, opts)
      data
    end

    # Create NFT Auction
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy new smart contract for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155). Operator can set a fee in percentage, which will be paid on top of the price of the asset. can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation. Before auction is created, seller must approve transfer of the NFT to the auction contract. Buyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token. Buyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called. Once there is higher bid then the actual one, the previous bidder&#x27;s funds will be returned to him and new bidder will be the current winning one. When auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.&lt;br/&gt; This operation deploys a smart contract on the blockchain.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def generate_auction_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.generate_auction ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.generate_auction"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#generate_auction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create NFT Marketplace
    # <h4>2 credits per API call.</h4><br/> <p>Deploy new smart contract for NFT marketplace logic. Smart contract enables marketplace operator to create new listing for NFT (ERC-721/1155). Operator can set a fee in percentage, which will be paid on top of the price of the asset. Listing can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during listing creation. Once the listing is created, seller must send the NFT asset to the smart contract. Buyer will buy the asset from the listing using native asset - send assets along the buyAssetFromListing() smart contract call, or via ERC20 token. Buyer of the listing must perform approval for the smart contract to access ERC20 token, before the actual buyAssetFromListing() method is called. Once both assets - from buyer and seller - are in the smart contract, NFT is sent to the buyer, price is sent to the seller and marketplace fee is set to the operator.<br/> This operation deploys a smart contract on the blockchain.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def generate_marketplace(body, opts = {})
      data, _status_code, _headers = generate_marketplace_with_http_info(body, opts)
      data
    end

    # Create NFT Marketplace
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy new smart contract for NFT marketplace logic. Smart contract enables marketplace operator to create new listing for NFT (ERC-721/1155). Operator can set a fee in percentage, which will be paid on top of the price of the asset. Listing can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during listing creation. Once the listing is created, seller must send the NFT asset to the smart contract. Buyer will buy the asset from the listing using native asset - send assets along the buyAssetFromListing() smart contract call, or via ERC20 token. Buyer of the listing must perform approval for the smart contract to access ERC20 token, before the actual buyAssetFromListing() method is called. Once both assets - from buyer and seller - are in the smart contract, NFT is sent to the buyer, price is sent to the seller and marketplace fee is set to the operator.&lt;br/&gt; This operation deploys a smart contract on the blockchain.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def generate_marketplace_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.generate_marketplace ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.generate_marketplace"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#generate_marketplace\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get auction details from the NFT Auction
    # <h4>1 credit per API call.</h4><br/><p>Get detail of the specific auction.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param id Auction ID
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20010]
    def get_auction(chain, contract_address, id, opts = {})
      data, _status_code, _headers = get_auction_with_http_info(chain, contract_address, id, opts)
      data
    end

    # Get auction details from the NFT Auction
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get detail of the specific auction.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param id Auction ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20010, Integer, Hash)>] InlineResponse20010 data, response status code and response headers
    def get_auction_with_http_info(chain, contract_address, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_auction ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_auction"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_auction"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BlockchainMarketplaceApi.get_auction"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/{chain}/{contractAddress}/{id}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s).sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20010' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_auction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Estimate block height based on time
    # <h4>1 credits per API call.</h4><br/> <p>Get estimated block height at given time. This is estimation, not an exact block height.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param chain Blockchain to work with
    # @param date Date and time in ISO 8601 string
    # @param [Hash] opts the optional parameters
    # @return [BigDecimal]
    def get_auction_estimated_time(chain, date, opts = {})
      data, _status_code, _headers = get_auction_estimated_time_with_http_info(chain, date, opts)
      data
    end

    # Estimate block height based on time
    # &lt;h4&gt;1 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Get estimated block height at given time. This is estimation, not an exact block height.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param date Date and time in ISO 8601 string
    # @param [Hash] opts the optional parameters
    # @return [Array<(BigDecimal, Integer, Hash)>] BigDecimal data, response status code and response headers
    def get_auction_estimated_time_with_http_info(chain, date, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_auction_estimated_time ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_auction_estimated_time"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'date' is set
      if @api_client.config.client_side_validation && date.nil?
        fail ArgumentError, "Missing the required parameter 'date' when calling BlockchainMarketplaceApi.get_auction_estimated_time"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/time/{chain}/{date}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'date' + '}', date.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'BigDecimal' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_auction_estimated_time\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Auction fee
    # <h4>1 credit per API call.</h4><br/><p>Get fee of the auction.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [BigDecimal]
    def get_auction_fee(chain, contract_address, opts = {})
      data, _status_code, _headers = get_auction_fee_with_http_info(chain, contract_address, opts)
      data
    end

    # Get NFT Auction fee
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get fee of the auction.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [Array<(BigDecimal, Integer, Hash)>] BigDecimal data, response status code and response headers
    def get_auction_fee_with_http_info(chain, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_auction_fee ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_auction_fee"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_auction_fee"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/{chain}/{contractAddress}/fee'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'BigDecimal' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_auction_fee\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Auction fee recipient
    # <h4>1 credit per API call.</h4><br/><p>Get fee recipient of the auction.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20011]
    def get_auction_fee_recipient(chain, contract_address, opts = {})
      data, _status_code, _headers = get_auction_fee_recipient_with_http_info(chain, contract_address, opts)
      data
    end

    # Get NFT Auction fee recipient
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get fee recipient of the auction.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20011, Integer, Hash)>] InlineResponse20011 data, response status code and response headers
    def get_auction_fee_recipient_with_http_info(chain, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_auction_fee_recipient ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_auction_fee_recipient"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_auction_fee_recipient"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/{chain}/{contractAddress}/recipient'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20011' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_auction_fee_recipient\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Marketplace fee
    # <h4>1 credit per API call.</h4><br/><p>Get fee of the marketplace.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [BigDecimal]
    def get_marketplace_fee(chain, contract_address, opts = {})
      data, _status_code, _headers = get_marketplace_fee_with_http_info(chain, contract_address, opts)
      data
    end

    # Get NFT Marketplace fee
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get fee of the marketplace.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [Array<(BigDecimal, Integer, Hash)>] BigDecimal data, response status code and response headers
    def get_marketplace_fee_with_http_info(chain, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_marketplace_fee ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_marketplace_fee"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_marketplace_fee"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/fee'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'BigDecimal' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_marketplace_fee\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Marketplace fee recipient
    # <h4>1 credit per API call.</h4><br/><p>Get fee recipient of the marketplace.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2009]
    def get_marketplace_fee_recipient(chain, contract_address, opts = {})
      data, _status_code, _headers = get_marketplace_fee_recipient_with_http_info(chain, contract_address, opts)
      data
    end

    # Get NFT Marketplace fee recipient
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get fee recipient of the marketplace.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2009, Integer, Hash)>] InlineResponse2009 data, response status code and response headers
    def get_marketplace_fee_recipient_with_http_info(chain, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_marketplace_fee_recipient ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_marketplace_fee_recipient"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_marketplace_fee_recipient"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/recipient'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse2009' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_marketplace_fee_recipient\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get listing from the NFT Marketplace
    # <h4>1 credit per API call.</h4><br/><p>Get detail of the specific listing.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param id Listing ID
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2008]
    def get_marketplace_listing(chain, contract_address, id, opts = {})
      data, _status_code, _headers = get_marketplace_listing_with_http_info(chain, contract_address, id, opts)
      data
    end

    # Get listing from the NFT Marketplace
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get detail of the specific listing.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param id Listing ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2008, Integer, Hash)>] InlineResponse2008 data, response status code and response headers
    def get_marketplace_listing_with_http_info(chain, contract_address, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_marketplace_listing ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_marketplace_listing"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'MATIC', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, MATIC, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_marketplace_listing"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BlockchainMarketplaceApi.get_marketplace_listing"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/listing/{id}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s).sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse2008' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_marketplace_listing\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get open/cancelled/sold listings from the NFT Marketplace
    # <h4>1 credit per API call.</h4><br/><p>Get list of listings in this marketplace.</p>
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param type Listing ID
    # @param [Hash] opts the optional parameters
    # @return [Array<String>]
    def get_marketplace_listings(chain, contract_address, type, opts = {})
      data, _status_code, _headers = get_marketplace_listings_with_http_info(chain, contract_address, type, opts)
      data
    end

    # Get open/cancelled/sold listings from the NFT Marketplace
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get list of listings in this marketplace.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address Contract address
    # @param type Listing ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<String>, Integer, Hash)>] Array<String> data, response status code and response headers
    def get_marketplace_listings_with_http_info(chain, contract_address, type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.get_marketplace_listings ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainMarketplaceApi.get_marketplace_listings"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['CELO'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of CELO"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainMarketplaceApi.get_marketplace_listings"
      end
      # verify the required parameter 'type' is set
      if @api_client.config.client_side_validation && type.nil?
        fail ArgumentError, "Missing the required parameter 'type' when calling BlockchainMarketplaceApi.get_marketplace_listings"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['INITIATED', 'SOLD', 'CANCELLED'].include?(type)
        fail ArgumentError, "invalid value for 'type', must be one of INITIATED, SOLD, CANCELLED"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/{type}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s).sub('{' + 'type' + '}', type.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<String>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#get_marketplace_listings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Sell asset on the NFT Marketplace
    # <h4>2 credits per API call.</h4><br/> <p>Create new listing on the marketplace. Only marketplace operator can establish those on behalf of the seller of the NFT. After listing is created, seller must approve the asset for spending to the marketplace smart contract. Only listing for existing NFTs can be created - seller must be owner of the NFT asset.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def sell_asset_on_marketplace(body, opts = {})
      data, _status_code, _headers = sell_asset_on_marketplace_with_http_info(body, opts)
      data
    end

    # Sell asset on the NFT Marketplace
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create new listing on the marketplace. Only marketplace operator can establish those on behalf of the seller of the NFT. After listing is created, seller must approve the asset for spending to the marketplace smart contract. Only listing for existing NFTs can be created - seller must be owner of the NFT asset.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def sell_asset_on_marketplace_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.sell_asset_on_marketplace ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.sell_asset_on_marketplace"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/sell'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#sell_asset_on_marketplace\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Settle auction of the asset on the NFT Auction
    # <h4>2 credits per API call.</h4><br/> <p>Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def settle_auction(body, opts = {})
      data, _status_code, _headers = settle_auction_with_http_info(body, opts)
      data
    end

    # Settle auction of the asset on the NFT Auction
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def settle_auction_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.settle_auction ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.settle_auction"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/settle'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#settle_auction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update NFT Auction fee
    # <h4>2 credits per API call.</h4><br/> <p>Update fee of the auction.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def update_auction_fee(body, opts = {})
      data, _status_code, _headers = update_auction_fee_with_http_info(body, opts)
      data
    end

    # Update NFT Auction fee
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Update fee of the auction.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def update_auction_fee_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.update_auction_fee ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.update_auction_fee"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/fee'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#update_auction_fee\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update NFT Auction fee recipient
    # <h4>2 credits per API call.</h4><br/> <p>Update fee recipient of the auction.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def update_auction_fee_recipient(body, opts = {})
      data, _status_code, _headers = update_auction_fee_recipient_with_http_info(body, opts)
      data
    end

    # Update NFT Auction fee recipient
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Update fee recipient of the auction.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def update_auction_fee_recipient_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.update_auction_fee_recipient ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.update_auction_fee_recipient"
      end
      # resource path
      local_var_path = '/v3/blockchain/auction/recipient'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#update_auction_fee_recipient\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update NFT Marketplace fee
    # <h4>2 credits per API call.</h4><br/> <p>Update fee of the marketplace.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def update_fee(body, opts = {})
      data, _status_code, _headers = update_fee_with_http_info(body, opts)
      data
    end

    # Update NFT Marketplace fee
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Update fee of the marketplace.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def update_fee_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.update_fee ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.update_fee"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/fee'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#update_fee\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update NFT Marketplace fee recipient
    # <h4>2 credits per API call.</h4><br/> <p>Update fee recipient of the marketplace.<br/> Supported blockchains: <ul> <li>Binance Smart Chain</li> <li>Harmony.ONE</li> <li>Ethereum</li> <li>Celo</li> <li>Polygon (Matic)</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2005]
    def update_fee_recipient(body, opts = {})
      data, _status_code, _headers = update_fee_recipient_with_http_info(body, opts)
      data
    end

    # Update NFT Marketplace fee recipient
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Update fee recipient of the marketplace.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Binance Smart Chain&lt;/li&gt; &lt;li&gt;Harmony.ONE&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Polygon (Matic)&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def update_fee_recipient_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainMarketplaceApi.update_fee_recipient ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainMarketplaceApi.update_fee_recipient"
      end
      # resource path
      local_var_path = '/v3/blockchain/marketplace/listing/recipient'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainMarketplaceApi#update_fee_recipient\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
