=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module Tatum
  class BlockchainNFTApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add NFT Minter
    # <h4>2 credits.</h4><br/> <p>Add new minter of NFT Tokens. This method adds minter permission to new minter address.<br/><br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def nft_add_minter(body, opts = {})
      data, _status_code, _headers = nft_add_minter_with_http_info(body, opts)
      data
    end

    # Add NFT Minter
    # &lt;h4&gt;2 credits.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Add new minter of NFT Tokens. This method adds minter permission to new minter address.&lt;br/&gt;&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def nft_add_minter_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_add_minter ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_add_minter"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/mint/add'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_add_minter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Burn NFT
    # <h4>100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.</h4><br/> <p>Burn one NFT Token. This method destroys any NFT token from smart contract defined in contractAddress.<br/><br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Tron</b></li> <li><b>Flow</b></li> <li><b>Binance Smart Chain</b></li> <li><b>Algorand</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def nft_burn_erc721(body, opts = {})
      data, _status_code, _headers = nft_burn_erc721_with_http_info(body, opts)
      data
    end

    # Burn NFT
    # &lt;h4&gt;100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Burn one NFT Token. This method destroys any NFT token from smart contract defined in contractAddress.&lt;br/&gt;&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tron&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Flow&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Algorand&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def nft_burn_erc721_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_burn_erc721 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_burn_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/burn'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_burn_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy NFT Smart Contract.
    # <h4>100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.</h4><br/> <p>Deploy NFT Smart Contract. This method creates new ERC721 Smart Contract (Non-Fungible Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once.<br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Flow</b></li> <li><b>Tron</b></li> <li><b>Binance Smart Chain</b></li> </ul> It is possible to see the code of the deployed contract <a href=\"https://github.com/tatumio/smart-contracts/tree/master/contracts/tatum\" target=\"_blank\">for EVM chains here</a>  or here <a href=\"https://github.com/tatumio/flow-contracts\" target=\"_blank\">for Flow</a>.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def nft_deploy_erc721(body, opts = {})
      data, _status_code, _headers = nft_deploy_erc721_with_http_info(body, opts)
      data
    end

    # Deploy NFT Smart Contract.
    # &lt;h4&gt;100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy NFT Smart Contract. This method creates new ERC721 Smart Contract (Non-Fungible Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once.&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Flow&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tron&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; It is possible to see the code of the deployed contract &lt;a href&#x3D;\&quot;https://github.com/tatumio/smart-contracts/tree/master/contracts/tatum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;for EVM chains here&lt;/a&gt;  or here &lt;a href&#x3D;\&quot;https://github.com/tatumio/flow-contracts\&quot; target&#x3D;\&quot;_blank\&quot;&gt;for Flow&lt;/a&gt;.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def nft_deploy_erc721_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_deploy_erc721 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_deploy_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_deploy_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Account balance
    # <h4>1 credit per API call.</h4><br/><p>Get NFTs on Account. Returns tokenIDs of tokens Account holds. This method is valid only for tokens deplyed using Tatum API - it reads data from the smart contract.</p> 
    # @param chain Blockchain to work with
    # @param address Account address
    # @param contract_address NFT contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [Array<String>]
    def nft_get_balance_erc721(chain, address, contract_address, opts = {})
      data, _status_code, _headers = nft_get_balance_erc721_with_http_info(chain, address, contract_address, opts)
      data
    end

    # Get NFT Account balance
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFTs on Account. Returns tokenIDs of tokens Account holds. This method is valid only for tokens deplyed using Tatum API - it reads data from the smart contract.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param address Account address
    # @param contract_address NFT contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(Array<String>, Integer, Hash)>] Array<String> data, response status code and response headers
    def nft_get_balance_erc721_with_http_info(chain, address, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_balance_erc721 ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_balance_erc721"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'TRON', 'FLOW', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, TRON, FLOW, BSC"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainNFTApi.nft_get_balance_erc721"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainNFTApi.nft_get_balance_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/balance/{chain}/{contractAddress}/{address}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<String>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_balance_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get contract address from transaction
    # <h4>1 credit per API call.</h4><br/> <p>Get NFT contract address from deploy transaction. This method is deprecated, use <a href=\"#operation/SCGetContractAddress\">Get contract address</a> instead.</p> 
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20037]
    def nft_get_contract_address(chain, hash, opts = {})
      data, _status_code, _headers = nft_get_contract_address_with_http_info(chain, hash, opts)
      data
    end

    # Get contract address from transaction
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Get NFT contract address from deploy transaction. This method is deprecated, use &lt;a href&#x3D;\&quot;#operation/SCGetContractAddress\&quot;&gt;Get contract address&lt;/a&gt; instead.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20037, Integer, Hash)>] InlineResponse20037 data, response status code and response headers
    def nft_get_contract_address_with_http_info(chain, hash, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_contract_address ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_contract_address"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'ONE', 'CELO', 'TRON', 'FLOW', 'MATIC', 'KCS', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, ONE, CELO, TRON, FLOW, MATIC, KCS, BSC"
      end
      # verify the required parameter 'hash' is set
      if @api_client.config.client_side_validation && hash.nil?
        fail ArgumentError, "Missing the required parameter 'hash' when calling BlockchainNFTApi.nft_get_contract_address"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/address/{chain}/{hash}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'hash' + '}', hash.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20037' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_contract_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Token Metadata
    # <h4>1 credit per API call.</h4><br/><p>Get NFT token metadata.</p>
    # @param chain Blockchain to work with
    # @param contract_address NFT contract address
    # @param token Token ID, required for all except SOL
    # @param [Hash] opts the optional parameters
    # @option opts [String] :account Account holding this token. FLOW only.
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20041]
    def nft_get_metadata_erc721(chain, contract_address, token, opts = {})
      data, _status_code, _headers = nft_get_metadata_erc721_with_http_info(chain, contract_address, token, opts)
      data
    end

    # Get NFT Token Metadata
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFT token metadata.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address NFT contract address
    # @param token Token ID, required for all except SOL
    # @param [Hash] opts the optional parameters
    # @option opts [String] :account Account holding this token. FLOW only.
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20041, Integer, Hash)>] InlineResponse20041 data, response status code and response headers
    def nft_get_metadata_erc721_with_http_info(chain, contract_address, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_metadata_erc721 ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_metadata_erc721"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'SOL', 'ONE', 'CELO', 'TRON', 'FLOW', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, SOL, ONE, CELO, TRON, FLOW, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainNFTApi.nft_get_metadata_erc721"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling BlockchainNFTApi.nft_get_metadata_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/metadata/{chain}/{contractAddress}/{token}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s).sub('{' + 'token' + '}', token.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'account'] = opts[:'account'] if !opts[:'account'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20041' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_metadata_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Token Provenance Data
    # <h4>1 credit per API call.</h4><br/><p>Get NFT token provenance data, valid only for provenance contract.</p>
    # @param chain Blockchain to work with
    # @param token_id Token ID
    # @param contract_address NFT contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [Array<InlineResponse20040>]
    def nft_get_provenance_data_erc721(chain, token_id, contract_address, opts = {})
      data, _status_code, _headers = nft_get_provenance_data_erc721_with_http_info(chain, token_id, contract_address, opts)
      data
    end

    # Get NFT Token Provenance Data
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFT token provenance data, valid only for provenance contract.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param token_id Token ID
    # @param contract_address NFT contract address
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(Array<InlineResponse20040>, Integer, Hash)>] Array<InlineResponse20040> data, response status code and response headers
    def nft_get_provenance_data_erc721_with_http_info(chain, token_id, contract_address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_provenance_data_erc721 ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_provenance_data_erc721"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, BSC"
      end
      # verify the required parameter 'token_id' is set
      if @api_client.config.client_side_validation && token_id.nil?
        fail ArgumentError, "Missing the required parameter 'token_id' when calling BlockchainNFTApi.nft_get_provenance_data_erc721"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainNFTApi.nft_get_provenance_data_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/provenance/{chain}/{contractAddress}/{tokenId}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'tokenId' + '}', token_id.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<InlineResponse20040>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_provenance_data_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT Token Royalty information
    # <h4>1 credit per API call.</h4><br/><p>Get NFT token royalty.</p>
    # @param chain Blockchain to work with
    # @param contract_address NFT contract address
    # @param token Token ID, required for all except SOL
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20042]
    def nft_get_royalty_erc721(chain, contract_address, token, opts = {})
      data, _status_code, _headers = nft_get_royalty_erc721_with_http_info(chain, contract_address, token, opts)
      data
    end

    # Get NFT Token Royalty information
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFT token royalty.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param contract_address NFT contract address
    # @param token Token ID, required for all except SOL
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20042, Integer, Hash)>] InlineResponse20042 data, response status code and response headers
    def nft_get_royalty_erc721_with_http_info(chain, contract_address, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_royalty_erc721 ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_royalty_erc721"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'SOL', 'ONE', 'CELO', 'TRON', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, SOL, ONE, CELO, TRON, BSC"
      end
      # verify the required parameter 'contract_address' is set
      if @api_client.config.client_side_validation && contract_address.nil?
        fail ArgumentError, "Missing the required parameter 'contract_address' when calling BlockchainNFTApi.nft_get_royalty_erc721"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling BlockchainNFTApi.nft_get_royalty_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/royalty/{chain}/{contractAddress}/{token}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'contractAddress' + '}', contract_address.to_s).sub('{' + 'token' + '}', token.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20042' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_royalty_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT tokens for address
    # <h4>1 credit per API call + 5 credits for each owned token.</h4><br/><p>Get NFTs on address. Returns all NFTs this address holds.</p> 
    # @param chain Blockchain to work with
    # @param address Account address
    # @param [Hash] opts the optional parameters
    # @return [Array<InlineResponse20039>]
    def nft_get_tokens_by_address_erc721(chain, address, opts = {})
      data, _status_code, _headers = nft_get_tokens_by_address_erc721_with_http_info(chain, address, opts)
      data
    end

    # Get NFT tokens for address
    # &lt;h4&gt;1 credit per API call + 5 credits for each owned token.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFTs on address. Returns all NFTs this address holds.&lt;/p&gt; 
    # @param chain Blockchain to work with
    # @param address Account address
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<InlineResponse20039>, Integer, Hash)>] Array<InlineResponse20039> data, response status code and response headers
    def nft_get_tokens_by_address_erc721_with_http_info(chain, address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_tokens_by_address_erc721 ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_tokens_by_address_erc721"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ALGO', 'CELO', 'MATIC', 'ETH'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ALGO, CELO, MATIC, ETH"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainNFTApi.nft_get_tokens_by_address_erc721"
      end
      # resource path
      local_var_path = '/v3/nft/address/balance/{chain}/{address}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<InlineResponse20039>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_tokens_by_address_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Transaction
    # <h4>1 credit per API call.</h4><br/><p>Get NFT transaction by transaction hash.</p>
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20038]
    def nft_get_transact_erc721(chain, hash, opts = {})
      data, _status_code, _headers = nft_get_transact_erc721_with_http_info(chain, hash, opts)
      data
    end

    # Get Transaction
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFT transaction by transaction hash.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param hash Transaction hash
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20038, Integer, Hash)>] InlineResponse20038 data, response status code and response headers
    def nft_get_transact_erc721_with_http_info(chain, hash, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_transact_erc721 ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_transact_erc721"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'MATIC', 'KCS', 'ONE', 'CELO', 'TRON', 'FLOW', 'BSC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, MATIC, KCS, ONE, CELO, TRON, FLOW, BSC"
      end
      # verify the required parameter 'hash' is set
      if @api_client.config.client_side_validation && hash.nil?
        fail ArgumentError, "Missing the required parameter 'hash' when calling BlockchainNFTApi.nft_get_transact_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/transaction/{chain}/{hash}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'hash' + '}', hash.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20038' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_transact_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT transactions by address
    # <h4>1 credit per API call.</h4><br/><p>Get NFT transactions by address. This includes incoming and outgoing transactions for the address.</p>
    # @param chain Blockchain to work with
    # @param address Account address
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @return [Array<null>]
    def nft_get_transaction_by_address(chain, address, token_address, page_size, opts = {})
      data, _status_code, _headers = nft_get_transaction_by_address_with_http_info(chain, address, token_address, page_size, opts)
      data
    end

    # Get NFT transactions by address
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFT transactions by address. This includes incoming and outgoing transactions for the address.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param address Account address
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @return [Array<(Array<null>, Integer, Hash)>] Array<null> data, response status code and response headers
    def nft_get_transaction_by_address_with_http_info(chain, address, token_address, page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_transaction_by_address ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_transaction_by_address"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['CELO', 'ETH', 'MATIC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of CELO, ETH, MATIC"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainNFTApi.nft_get_transaction_by_address"
      end
      # verify the required parameter 'token_address' is set
      if @api_client.config.client_side_validation && token_address.nil?
        fail ArgumentError, "Missing the required parameter 'token_address' when calling BlockchainNFTApi.nft_get_transaction_by_address"
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling BlockchainNFTApi.nft_get_transaction_by_address"
      end
      # resource path
      local_var_path = '/v3/nft/transaction/{chain}/{address}/{tokenAddress}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'address' + '}', address.to_s).sub('{' + 'tokenAddress' + '}', token_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'from'] = opts[:'from'] if !opts[:'from'].nil?
      query_params[:'to'] = opts[:'to'] if !opts[:'to'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<null>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_transaction_by_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NFT transactions by token
    # <h4>1 credit per API call.</h4><br/><p>Get NFT transactions by token. This includes incoming and outgoing transactions for the token.</p>
    # @param chain Blockchain to work with
    # @param token_id NFT Token ID
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @return [Array<null>]
    def nft_get_transaction_by_token(chain, token_id, token_address, page_size, opts = {})
      data, _status_code, _headers = nft_get_transaction_by_token_with_http_info(chain, token_id, token_address, page_size, opts)
      data
    end

    # Get NFT transactions by token
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get NFT transactions by token. This includes incoming and outgoing transactions for the token.&lt;/p&gt;
    # @param chain Blockchain to work with
    # @param token_id NFT Token ID
    # @param token_address Token address
    # @param page_size Max number of items per page is 50.
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :offset Offset to obtain next page of the data.
    # @option opts [BigDecimal] :from Transactions from this block onwords will be included.
    # @option opts [BigDecimal] :to Transactions up to this block will be included.
    # @return [Array<(Array<null>, Integer, Hash)>] Array<null> data, response status code and response headers
    def nft_get_transaction_by_token_with_http_info(chain, token_id, token_address, page_size, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_get_transaction_by_token ...'
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling BlockchainNFTApi.nft_get_transaction_by_token"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['CELO', 'ETH', 'MATIC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of CELO, ETH, MATIC"
      end
      # verify the required parameter 'token_id' is set
      if @api_client.config.client_side_validation && token_id.nil?
        fail ArgumentError, "Missing the required parameter 'token_id' when calling BlockchainNFTApi.nft_get_transaction_by_token"
      end
      # verify the required parameter 'token_address' is set
      if @api_client.config.client_side_validation && token_address.nil?
        fail ArgumentError, "Missing the required parameter 'token_address' when calling BlockchainNFTApi.nft_get_transaction_by_token"
      end
      # verify the required parameter 'page_size' is set
      if @api_client.config.client_side_validation && page_size.nil?
        fail ArgumentError, "Missing the required parameter 'page_size' when calling BlockchainNFTApi.nft_get_transaction_by_token"
      end
      # resource path
      local_var_path = '/v3/nft/transaction/tokenId/{chain}/{tokenAddress}/{tokenId}'.sub('{' + 'chain' + '}', chain.to_s).sub('{' + 'tokenId' + '}', token_id.to_s).sub('{' + 'tokenAddress' + '}', token_address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pageSize'] = page_size
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'from'] = opts[:'from'] if !opts[:'from'].nil?
      query_params[:'to'] = opts[:'to'] if !opts[:'to'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<null>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_get_transaction_by_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Mint NFT
    # <h4>100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.</h4><br/> <p>Create one NFT Token and transfer it to destination account. Create and transfer any NFT token from smart contract defined in contractAddress. It is possible to add URL to the created token with a more detailed information about it.<br/><br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Solana</b></li> <li><b>Harmony.ONE</b></li> <li><b>Tron</b></li> <li><b>Flow</b></li> <li><b>Binance Smart Chain</b></li> </ul> <br/> For Solana, NFTs are not deployed, only minted right away. Newly created NFT creates new address on the blockchain and owner of the NFT owns with it's private key the account of the NFT. <br/> This operation works in two modes.  First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.  Second mode works without private key or signature id. Mint NFT requests use built-in smart contract, private key and token id which are provided by Tatum. You dont need to provide fromPrivateKey (or signatureId), contractAddress and tokenId fields to perform the mint NFT request.  Performed request without fromPrivateKey or signatureId fields will be populated with following attributes:  <ul>   <li><b>fromPrivateKey</b> - a built-in private key connected to the address from which will be NFT transaction fees paid.</li>   <li><b>tokenId</b> - a counter which starts from 0 and is increased for each NFT mint request by 1. The tokenId is provided per each chain and mainnet/testnet version of network.</li>   <li><b>contractAddress</b> - represents Tatum built in smart contract address of the minted NFT.</li> </ul>  The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debitted in form of credits. The credits are debitted only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum.  It means if you perform mint NFT request with following body:  <pre>{   \"chain\": \"CELO\",   \"to\": \"0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\",   \"url\": \"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\" }</pre>  The fields contractAddress, fromPrivateKey and tokenId will be internally filled in following way:  <pre>{   \"chain\": \"CELO\",   \"to\": \"0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\",   \"url\": \"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\",   \"fromPrivateKey\": \"{tatumBuiltInPrivateKey}\",   \"tokenId\": \"{tatumBuiltInTokenId + 1}\",   \"contractAddress\": \"0x45871ED5F15203C0ce791eFE5f4B5044833aE10e\" }</pre>  Keep in mind that your credit amount will be debitted accordingly to the rate of the selected blockchain and cost of transaction fees.   We have prepared following smart contracts for minting without private key: <table>   <tr>     <th>Chain</th>     <th>Testnet/Mainnet</th>     <th>Address</th>     <th>Smart contract address</th>   </tr>   <tr>     <td>MATIC</td>     <td>Testnet</td>     <td>0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5</td>     <td>0xCd2AdA00c48A27FAa5Cc67F9A1ed55B89dDf7F77</td>   </tr>   <tr>     <td>BSC</td>     <td>Testnet</td>     <td>0xc16ae5e8c985b906935a0cadf4e24f0400531883</td>     <td>0xF73075aa67561791352fbEe8278115487Fd90ab6</td>   </tr>   <tr>     <td>ONE</td>     <td>Testnet</td>     <td>0x8906f62d40293ddca77fdf6714c3f63265deddf0</td>     <td>0x427ddbe3ad5e1e77e010c02e61e9bdef82dcaeea</td>   </tr>   <tr>     <td>ETH</td>     <td>Testnet</td>     <td>0x51abC4c9e7BFfaA99bBE4dDC33d75067EBD0384F</td>     <td>0xAe7D8842D0295B1f24a8842cBd5eB83Ae2fd0946</td>   </tr>   <tr>     <td>CELO</td>     <td>Testnet</td>     <td>0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F</td>     <td>0x45871ED5F15203C0ce791eFE5f4B5044833aE10e</td>   </tr>   <tr>     <td>MATIC</td>     <td>Mainnet</td>     <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>     <td>0x6709bdda623af7eb152cb2fe2562ab7e031e564f</td>   </tr>   <tr>     <td>KCS</td>     <td>Mainnet</td>     <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>     <td>0x6709bdda623af7eb152cb2fe2562ab7e031e564f</td>   </tr>   <tr>     <td>BSC</td>     <td>Mainnet</td>     <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>     <td>0x6709bdda623af7eb152cb2fe2562ab7e031e564f</td>   </tr>   <tr>     <td>ETH</td>     <td>Mainnet</td>     <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>     <td>0x789c00ed7ddd72a806dbac40df926df32fde3c2f</td>   </tr>   <tr>     <td>ONE</td>     <td>Mainnet</td>     <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>     <td>0x6709bdda623af7eb152cb2fe2562ab7e031e564f</td>   </tr>   <tr>     <td>CELO</td>     <td>Mainnet</td>     <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>     <td>0x6709bdda623af7eb152cb2fe2562ab7e031e564f</td>   </tr>  </table> To add ETH mainnet smart contract contact sales@tatum.io. If there will be a low amount of coins on any testnet address you are free to send coins to the address. In future we will provide also addresses and smart contracts for the mainnet version.        </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20035]
    def nft_mint_erc721(body, opts = {})
      data, _status_code, _headers = nft_mint_erc721_with_http_info(body, opts)
      data
    end

    # Mint NFT
    # &lt;h4&gt;100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create one NFT Token and transfer it to destination account. Create and transfer any NFT token from smart contract defined in contractAddress. It is possible to add URL to the created token with a more detailed information about it.&lt;br/&gt;&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Solana&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tron&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Flow&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; For Solana, NFTs are not deployed, only minted right away. Newly created NFT creates new address on the blockchain and owner of the NFT owns with it&#x27;s private key the account of the NFT. &lt;br/&gt; This operation works in two modes.  First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.  Second mode works without private key or signature id. Mint NFT requests use built-in smart contract, private key and token id which are provided by Tatum. You dont need to provide fromPrivateKey (or signatureId), contractAddress and tokenId fields to perform the mint NFT request.  Performed request without fromPrivateKey or signatureId fields will be populated with following attributes:  &lt;ul&gt;   &lt;li&gt;&lt;b&gt;fromPrivateKey&lt;/b&gt; - a built-in private key connected to the address from which will be NFT transaction fees paid.&lt;/li&gt;   &lt;li&gt;&lt;b&gt;tokenId&lt;/b&gt; - a counter which starts from 0 and is increased for each NFT mint request by 1. The tokenId is provided per each chain and mainnet/testnet version of network.&lt;/li&gt;   &lt;li&gt;&lt;b&gt;contractAddress&lt;/b&gt; - represents Tatum built in smart contract address of the minted NFT.&lt;/li&gt; &lt;/ul&gt;  The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debitted in form of credits. The credits are debitted only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum.  It means if you perform mint NFT request with following body:  &lt;pre&gt;{   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot; }&lt;/pre&gt;  The fields contractAddress, fromPrivateKey and tokenId will be internally filled in following way:  &lt;pre&gt;{   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;{tatumBuiltInPrivateKey}\&quot;,   \&quot;tokenId\&quot;: \&quot;{tatumBuiltInTokenId + 1}\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x45871ED5F15203C0ce791eFE5f4B5044833aE10e\&quot; }&lt;/pre&gt;  Keep in mind that your credit amount will be debitted accordingly to the rate of the selected blockchain and cost of transaction fees.   We have prepared following smart contracts for minting without private key: &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Chain&lt;/th&gt;     &lt;th&gt;Testnet/Mainnet&lt;/th&gt;     &lt;th&gt;Address&lt;/th&gt;     &lt;th&gt;Smart contract address&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;MATIC&lt;/td&gt;     &lt;td&gt;Testnet&lt;/td&gt;     &lt;td&gt;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5&lt;/td&gt;     &lt;td&gt;0xCd2AdA00c48A27FAa5Cc67F9A1ed55B89dDf7F77&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BSC&lt;/td&gt;     &lt;td&gt;Testnet&lt;/td&gt;     &lt;td&gt;0xc16ae5e8c985b906935a0cadf4e24f0400531883&lt;/td&gt;     &lt;td&gt;0xF73075aa67561791352fbEe8278115487Fd90ab6&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;ONE&lt;/td&gt;     &lt;td&gt;Testnet&lt;/td&gt;     &lt;td&gt;0x8906f62d40293ddca77fdf6714c3f63265deddf0&lt;/td&gt;     &lt;td&gt;0x427ddbe3ad5e1e77e010c02e61e9bdef82dcaeea&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;ETH&lt;/td&gt;     &lt;td&gt;Testnet&lt;/td&gt;     &lt;td&gt;0x51abC4c9e7BFfaA99bBE4dDC33d75067EBD0384F&lt;/td&gt;     &lt;td&gt;0xAe7D8842D0295B1f24a8842cBd5eB83Ae2fd0946&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;CELO&lt;/td&gt;     &lt;td&gt;Testnet&lt;/td&gt;     &lt;td&gt;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F&lt;/td&gt;     &lt;td&gt;0x45871ED5F15203C0ce791eFE5f4B5044833aE10e&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;MATIC&lt;/td&gt;     &lt;td&gt;Mainnet&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;     &lt;td&gt;0x6709bdda623af7eb152cb2fe2562ab7e031e564f&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;KCS&lt;/td&gt;     &lt;td&gt;Mainnet&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;     &lt;td&gt;0x6709bdda623af7eb152cb2fe2562ab7e031e564f&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BSC&lt;/td&gt;     &lt;td&gt;Mainnet&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;     &lt;td&gt;0x6709bdda623af7eb152cb2fe2562ab7e031e564f&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;ETH&lt;/td&gt;     &lt;td&gt;Mainnet&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;     &lt;td&gt;0x789c00ed7ddd72a806dbac40df926df32fde3c2f&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;ONE&lt;/td&gt;     &lt;td&gt;Mainnet&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;     &lt;td&gt;0x6709bdda623af7eb152cb2fe2562ab7e031e564f&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;CELO&lt;/td&gt;     &lt;td&gt;Mainnet&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;     &lt;td&gt;0x6709bdda623af7eb152cb2fe2562ab7e031e564f&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt; To add ETH mainnet smart contract contact sales@tatum.io. If there will be a low amount of coins on any testnet address you are free to send coins to the address. In future we will provide also addresses and smart contracts for the mainnet version.        &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20035, Integer, Hash)>] InlineResponse20035 data, response status code and response headers
    def nft_mint_erc721_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_mint_erc721 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_mint_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/mint'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20035' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_mint_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Mint NFT Multiple Tokens
    # <h4>100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.</h4><br/> <p>Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress.<br/><br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Tron</b></li> <li><b>Flow</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse20036]
    def nft_mint_multiple_erc721(body, opts = {})
      data, _status_code, _headers = nft_mint_multiple_erc721_with_http_info(body, opts)
      data
    end

    # Mint NFT Multiple Tokens
    # &lt;h4&gt;100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress.&lt;br/&gt;&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tron&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Flow&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse20036, Integer, Hash)>] InlineResponse20036 data, response status code and response headers
    def nft_mint_multiple_erc721_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_mint_multiple_erc721 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_mint_multiple_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/mint/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20036' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_mint_multiple_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Transfer NFT Token
    # <h4>100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.</h4><br/> <p>Transfer NFT Tokens from account to account. Transfer any NFT token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId can be transfered. This method invokes ERC721 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.<br/><br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Flow</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Tron</b></li> <li><b>Binance Smart Chain</b></li> <li><b>Algorand</b></li> <li><b>Solana</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Algorand is unique a way that the receiving account should be ready before sending the NFT asset. To perform this, the receiving account should transfer the NFT asset with 0 amount to itself. During the process, it's using the same API as the main transaction: the only difference is that the \"fromPrivateKey\" should be the privateKey of the receiving account. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def nft_transfer_erc721(body, opts = {})
      data, _status_code, _headers = nft_transfer_erc721_with_http_info(body, opts)
      data
    end

    # Transfer NFT Token
    # &lt;h4&gt;100 credits per API call on FLOW, 2 credits on another chains. Tatum covers the fee connected to the transaction costs in subscription credits for FLOW. This operation can be done on mainnet only for paid plans.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Transfer NFT Tokens from account to account. Transfer any NFT token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId can be transfered. This method invokes ERC721 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.&lt;br/&gt;&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Flow&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tron&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Algorand&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Solana&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Algorand is unique a way that the receiving account should be ready before sending the NFT asset. To perform this, the receiving account should transfer the NFT asset with 0 amount to itself. During the process, it&#x27;s using the same API as the main transaction: the only difference is that the \&quot;fromPrivateKey\&quot; should be the privateKey of the receiving account. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def nft_transfer_erc721_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_transfer_erc721 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_transfer_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/transaction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_transfer_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Royalty NFT
    # <h4>2 credits per API call.</h4><br/> <p>Update royalty cashback value for one NFT Token. This method updates the first royalty value of specific author for 1 token. If royalty value is set to 0, it will disable the royalty system for the token. Only from author's address of the royalty can change it's royalty value, not the owner of the token.<br/><br/> Tatum now supports NFT these blockchains:<br/> <ul> <li><b>Ethereum</b></li> <li><b>Polygon (Matic)</b></li> <li><b>Kcs (KCS)</b></li> <li><b>Celo</b></li> <li><b>Harmony.ONE</b></li> <li><b>Tron</b></li> <li><b>Binance Smart Chain</b></li> </ul> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations. (default to ethereum-ropsten)
    # @return [InlineResponse2005]
    def nft_update_cashback_erc721(body, opts = {})
      data, _status_code, _headers = nft_update_cashback_erc721_with_http_info(body, opts)
      data
    end

    # Update Royalty NFT
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Update royalty cashback value for one NFT Token. This method updates the first royalty value of specific author for 1 token. If royalty value is set to 0, it will disable the royalty system for the token. Only from author&#x27;s address of the royalty can change it&#x27;s royalty value, not the owner of the token.&lt;br/&gt;&lt;br/&gt; Tatum now supports NFT these blockchains:&lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Ethereum&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Polygon (Matic)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Kcs (KCS)&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Celo&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Harmony.ONE&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tron&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;Binance Smart Chain&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_testnet_type Type of Ethereum testnet. Defaults to ropsten. Valid only for ETH invocations.
    # @return [Array<(InlineResponse2005, Integer, Hash)>] InlineResponse2005 data, response status code and response headers
    def nft_update_cashback_erc721_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainNFTApi.nft_update_cashback_erc721 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainNFTApi.nft_update_cashback_erc721"
      end
      if @api_client.config.client_side_validation && opts[:'x_testnet_type'] && !['ethereum-ropsten', 'ethereum-rinkeby'].include?(opts[:'x_testnet_type'])
        fail ArgumentError, 'invalid value for "x_testnet_type", must be one of ethereum-ropsten, ethereum-rinkeby'
      end
      # resource path
      local_var_path = '/v3/nft/royalty'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x-testnet-type'] = opts[:'x_testnet_type'] if !opts[:'x_testnet_type'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse2005' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainNFTApi#nft_update_cashback_erc721\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
