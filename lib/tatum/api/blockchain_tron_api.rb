=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module Tatum
  class BlockchainTronApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Generate Tron wallet
    # <h4>1 credit per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m'/44'/195'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/tron/bips/blob/master/bip-0044.mediawiki</a>.         Generate BIP44 compatible Tron wallet.</p> 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mnemonic Mnemonic to use for generation of extended public and private keys.
    # @return [TronWallet]
    def generate_tronwallet(opts = {})
      data, _status_code, _headers = generate_tronwallet_with_http_info(opts)
      data
    end

    # Generate Tron wallet
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.&lt;br/&gt;Each address is identified by 3 main values:&lt;ul&gt;&lt;li&gt;Private Key - your secret value, which should never be revealed&lt;/li&gt;&lt;li&gt;Public Key - public address to be published&lt;/li&gt;&lt;li&gt;Derivation index - index of generated address&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;&lt;p&gt;Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#x27;/44&#x27;/195&#x27;/0&#x27;/0. More about BIP44 HD wallets can be found here - &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\&quot;&gt;https://github.com/tron/bips/blob/master/bip-0044.mediawiki&lt;/a&gt;.         Generate BIP44 compatible Tron wallet.&lt;/p&gt; 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mnemonic Mnemonic to use for generation of extended public and private keys.
    # @return [Array<(TronWallet, Integer, Hash)>] TronWallet data, response status code and response headers
    def generate_tronwallet_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.generate_tronwallet ...'
      end
      # resource path
      local_var_path = '/v3/tron/wallet'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'mnemonic'] = opts[:'mnemonic'] if !opts[:'mnemonic'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'TronWallet' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#generate_tronwallet\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tron Account transactions
    # <h4>5 credits per API call.</h4><br/><p>Get Tron Account transactions. Default page size is 200 transactions per request.</p>
    # @param address Address to get transactions for.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :_next If
    # @return [InlineResponse20064]
    def tron_account_tx(address, opts = {})
      data, _status_code, _headers = tron_account_tx_with_http_info(address, opts)
      data
    end

    # Get Tron Account transactions
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Tron Account transactions. Default page size is 200 transactions per request.&lt;/p&gt;
    # @param address Address to get transactions for.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :_next If
    # @return [Array<(InlineResponse20064, Integer, Hash)>] InlineResponse20064 data, response status code and response headers
    def tron_account_tx_with_http_info(address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_account_tx ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainTronApi.tron_account_tx"
      end
      # resource path
      local_var_path = '/v3/tron/transaction/account/{address}'.sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'next'] = opts[:'_next'] if !opts[:'_next'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20064' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_account_tx\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tron Account TRC20 transactions
    # <h4>5 credits per API call.</h4><br/><p>Get Tron Account TRC20 transactions. Default page size is 200 transactions per request.</p>
    # @param address Address to get transactions for.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :_next If
    # @return [InlineResponse20065]
    def tron_account_tx20(address, opts = {})
      data, _status_code, _headers = tron_account_tx20_with_http_info(address, opts)
      data
    end

    # Get Tron Account TRC20 transactions
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Tron Account TRC20 transactions. Default page size is 200 transactions per request.&lt;/p&gt;
    # @param address Address to get transactions for.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :_next If
    # @return [Array<(InlineResponse20065, Integer, Hash)>] InlineResponse20065 data, response status code and response headers
    def tron_account_tx20_with_http_info(address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_account_tx20 ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainTronApi.tron_account_tx20"
      end
      # resource path
      local_var_path = '/v3/tron/transaction/account/{address}/trc20'.sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'next'] = opts[:'_next'] if !opts[:'_next'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20065' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_account_tx20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Broadcast Tron transaction
    # <h4>5 credits per API call.</h4><br/> <p>Broadcast Tron transaction. This method is used internally from Tatum Middleware or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_broadcast(body, opts = {})
      data, _status_code, _headers = tron_broadcast_with_http_info(body, opts)
      data
    end

    # Broadcast Tron transaction
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Broadcast Tron transaction. This method is used internally from Tatum Middleware or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_broadcast_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_broadcast ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_broadcast"
      end
      # resource path
      local_var_path = '/v3/tron/broadcast'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_broadcast\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Tron TRC10 token
    # <h4>10 credits per API call.</h4><br/> <p>Create Tron TRC10 token. 1 account can create only 1 token. All supply of the tokens are transfered to the issuer account 100 seconds after the creation.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_create_trc10(body, opts = {})
      data, _status_code, _headers = tron_create_trc10_with_http_info(body, opts)
      data
    end

    # Create Tron TRC10 token
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create Tron TRC10 token. 1 account can create only 1 token. All supply of the tokens are transfered to the issuer account 100 seconds after the creation.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_create_trc10_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_create_trc10 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_create_trc10"
      end
      # resource path
      local_var_path = '/v3/tron/trc10/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_create_trc10\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Tron TRC20 token
    # <h4>10 credits per API call.</h4><br/> <p>Create Tron TRC20 token. 1 account can create only 1 token. All supply of the tokens are transfered to the issuer account 100 seconds after the creation.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_create_trc20(body, opts = {})
      data, _status_code, _headers = tron_create_trc20_with_http_info(body, opts)
      data
    end

    # Create Tron TRC20 token
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create Tron TRC20 token. 1 account can create only 1 token. All supply of the tokens are transfered to the issuer account 100 seconds after the creation.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_create_trc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_create_trc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_create_trc20"
      end
      # resource path
      local_var_path = '/v3/tron/trc20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_create_trc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Freeze Tron balance
    # <h4>10 credits per API call.</h4><br/> <p>Freeze Tron assets on the address. By freezing assets, you can obtain energy or bandwith to perform transactions.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_freeze(body, opts = {})
      data, _status_code, _headers = tron_freeze_with_http_info(body, opts)
      data
    end

    # Freeze Tron balance
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Freeze Tron assets on the address. By freezing assets, you can obtain energy or bandwith to perform transactions.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_freeze_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_freeze ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_freeze"
      end
      # resource path
      local_var_path = '/v3/tron/freezeBalance'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_freeze\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generate Tron deposit address from Extended public key
    # <h4>5 credit per API call.</h4><br/> <p>Generate Tron deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^32 addresses starting from index 0 until 2^31.</p> 
    # @param xpub Extended public key of wallet.
    # @param index Derivation index of desired address to be generated.
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20062]
    def tron_generate_address(xpub, index, opts = {})
      data, _status_code, _headers = tron_generate_address_with_http_info(xpub, index, opts)
      data
    end

    # Generate Tron deposit address from Extended public key
    # &lt;h4&gt;5 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Generate Tron deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^32 addresses starting from index 0 until 2^31.&lt;/p&gt; 
    # @param xpub Extended public key of wallet.
    # @param index Derivation index of desired address to be generated.
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20062, Integer, Hash)>] InlineResponse20062 data, response status code and response headers
    def tron_generate_address_with_http_info(xpub, index, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_generate_address ...'
      end
      # verify the required parameter 'xpub' is set
      if @api_client.config.client_side_validation && xpub.nil?
        fail ArgumentError, "Missing the required parameter 'xpub' when calling BlockchainTronApi.tron_generate_address"
      end
      # verify the required parameter 'index' is set
      if @api_client.config.client_side_validation && index.nil?
        fail ArgumentError, "Missing the required parameter 'index' when calling BlockchainTronApi.tron_generate_address"
      end
      # resource path
      local_var_path = '/v3/tron/address/{xpub}/{index}'.sub('{' + 'xpub' + '}', xpub.to_s).sub('{' + 'index' + '}', index.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20062' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_generate_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generate Tron private key
    # <h4>10 credit per API call.</h4><br/> <p>Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [PrivKey]
    def tron_generate_address_private_key(body, opts = {})
      data, _status_code, _headers = tron_generate_address_private_key_with_http_info(body, opts)
      data
    end

    # Generate Tron private key
    # &lt;h4&gt;10 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PrivKey, Integer, Hash)>] PrivKey data, response status code and response headers
    def tron_generate_address_private_key_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_generate_address_private_key ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_generate_address_private_key"
      end
      # resource path
      local_var_path = '/v3/tron/wallet/priv'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'PrivKey' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_generate_address_private_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tron Account by address
    # <h4>5 credits per API call.</h4><br/><p>Get Tron account by address.</p>
    # @param address Account address.
    # @param [Hash] opts the optional parameters
    # @return [TronAccount]
    def tron_get_account(address, opts = {})
      data, _status_code, _headers = tron_get_account_with_http_info(address, opts)
      data
    end

    # Get Tron Account by address
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Tron account by address.&lt;/p&gt;
    # @param address Account address.
    # @param [Hash] opts the optional parameters
    # @return [Array<(TronAccount, Integer, Hash)>] TronAccount data, response status code and response headers
    def tron_get_account_with_http_info(address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_get_account ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling BlockchainTronApi.tron_get_account"
      end
      # resource path
      local_var_path = '/v3/tron/account/{address}'.sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'TronAccount' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_get_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tron block
    # <h4>5 credits per API call.</h4><br/><p>Get Tron block by hash or height.</p>
    # @param hash Block hash or height.
    # @param [Hash] opts the optional parameters
    # @return [TronBlock]
    def tron_get_block(hash, opts = {})
      data, _status_code, _headers = tron_get_block_with_http_info(hash, opts)
      data
    end

    # Get Tron block
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Tron block by hash or height.&lt;/p&gt;
    # @param hash Block hash or height.
    # @param [Hash] opts the optional parameters
    # @return [Array<(TronBlock, Integer, Hash)>] TronBlock data, response status code and response headers
    def tron_get_block_with_http_info(hash, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_get_block ...'
      end
      # verify the required parameter 'hash' is set
      if @api_client.config.client_side_validation && hash.nil?
        fail ArgumentError, "Missing the required parameter 'hash' when calling BlockchainTronApi.tron_get_block"
      end
      # resource path
      local_var_path = '/v3/tron/block/{hash}'.sub('{' + 'hash' + '}', hash.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'TronBlock' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_get_block\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get current Tron block
    # <h4>5 credits per API call.</h4><br/><p>Get current Tron block.</p>
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20063]
    def tron_get_current_block(opts = {})
      data, _status_code, _headers = tron_get_current_block_with_http_info(opts)
      data
    end

    # Get current Tron block
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get current Tron block.&lt;/p&gt;
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20063, Integer, Hash)>] InlineResponse20063 data, response status code and response headers
    def tron_get_current_block_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_get_current_block ...'
      end
      # resource path
      local_var_path = '/v3/tron/info'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'InlineResponse20063' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_get_current_block\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tron transaction by hash
    # <h4>5 credits per API call.</h4><br/><p>Get Tron transaction by hash.</p>
    # @param hash Transaction hash.
    # @param [Hash] opts the optional parameters
    # @return [TronTx]
    def tron_get_transaction(hash, opts = {})
      data, _status_code, _headers = tron_get_transaction_with_http_info(hash, opts)
      data
    end

    # Get Tron transaction by hash
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Get Tron transaction by hash.&lt;/p&gt;
    # @param hash Transaction hash.
    # @param [Hash] opts the optional parameters
    # @return [Array<(TronTx, Integer, Hash)>] TronTx data, response status code and response headers
    def tron_get_transaction_with_http_info(hash, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_get_transaction ...'
      end
      # verify the required parameter 'hash' is set
      if @api_client.config.client_side_validation && hash.nil?
        fail ArgumentError, "Missing the required parameter 'hash' when calling BlockchainTronApi.tron_get_transaction"
      end
      # resource path
      local_var_path = '/v3/tron/transaction/{hash}'.sub('{' + 'hash' + '}', hash.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'TronTx' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_get_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Tron transaction
    # <h4>10 credits per API call.</h4><br/> <p>Send Tron transaction from address to address.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_transfer(body, opts = {})
      data, _status_code, _headers = tron_transfer_with_http_info(body, opts)
      data
    end

    # Send Tron transaction
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Tron transaction from address to address.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_transfer"
      end
      # resource path
      local_var_path = '/v3/tron/transaction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Tron TRC10 transaction
    # <h4>10 credits per API call.</h4><br/> <p>Send Tron TRC10 transaction from address to address.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_transfer_trc10(body, opts = {})
      data, _status_code, _headers = tron_transfer_trc10_with_http_info(body, opts)
      data
    end

    # Send Tron TRC10 transaction
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Tron TRC10 transaction from address to address.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_transfer_trc10_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_transfer_trc10 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_transfer_trc10"
      end
      # resource path
      local_var_path = '/v3/tron/trc10/transaction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_transfer_trc10\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Tron TRC20 transaction
    # <h4>10 credits per API call.</h4><br/> <p>Send Tron TRC20 transaction from address to address.<br/><br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [TransactionHash]
    def tron_transfer_trc20(body, opts = {})
      data, _status_code, _headers = tron_transfer_trc20_with_http_info(body, opts)
      data
    end

    # Send Tron TRC20 transaction
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Tron TRC20 transaction from address to address.&lt;br/&gt;&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, it is possible to use the Tatum client library for supported languages or Tatum Middleware with a custom key management system. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransactionHash, Integer, Hash)>] TransactionHash data, response status code and response headers
    def tron_transfer_trc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_transfer_trc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling BlockchainTronApi.tron_transfer_trc20"
      end
      # resource path
      local_var_path = '/v3/tron/trc20/transaction'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'TransactionHash' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_transfer_trc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tron TRC10 token detail
    # <h4>5 credits per API call.</h4><br/> <p>Get Tron TRC10 token details.</p> 
    # @param id TRC10 token ID
    # @param [Hash] opts the optional parameters
    # @return [TronTrc10Detail]
    def tron_trc10_detail(id, opts = {})
      data, _status_code, _headers = tron_trc10_detail_with_http_info(id, opts)
      data
    end

    # Get Tron TRC10 token detail
    # &lt;h4&gt;5 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Get Tron TRC10 token details.&lt;/p&gt; 
    # @param id TRC10 token ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(TronTrc10Detail, Integer, Hash)>] TronTrc10Detail data, response status code and response headers
    def tron_trc10_detail_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BlockchainTronApi.tron_trc10_detail ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BlockchainTronApi.tron_trc10_detail"
      end
      # resource path
      local_var_path = '/v3/tron/trc10/detail/{id}'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'TronTrc10Detail' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BlockchainTronApi#tron_trc10_detail\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
