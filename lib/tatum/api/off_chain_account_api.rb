=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module Tatum
  class OffChainAccountApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Check, if deposit address is assigned
    # <h4>1 credit per API call.</h4><br/> <p>Check, whether blockchain address for given currency is registered within Tatum and assigned to Tatum Account. Returns account this address belongs to, otherwise throws an error.</p> 
    # @param currency Currency
    # @param address Blockchain Address to check
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index In case of XLM or XRP, this is a memo or DestinationTag to search for.
    # @return [Account]
    def address_exists(currency, address, opts = {})
      data, _status_code, _headers = address_exists_with_http_info(currency, address, opts)
      data
    end

    # Check, if deposit address is assigned
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Check, whether blockchain address for given currency is registered within Tatum and assigned to Tatum Account. Returns account this address belongs to, otherwise throws an error.&lt;/p&gt; 
    # @param currency Currency
    # @param address Blockchain Address to check
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index In case of XLM or XRP, this is a memo or DestinationTag to search for.
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def address_exists_with_http_info(currency, address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainAccountApi.address_exists ...'
      end
      # verify the required parameter 'currency' is set
      if @api_client.config.client_side_validation && currency.nil?
        fail ArgumentError, "Missing the required parameter 'currency' when calling OffChainAccountApi.address_exists"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling OffChainAccountApi.address_exists"
      end
      # resource path
      local_var_path = '/v3/offchain/account/address/{address}/{currency}'.sub('{' + 'currency' + '}', currency.to_s).sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'index'] = opts[:'index'] if !opts[:'index'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Account' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainAccountApi#address_exists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Assign address for account
    # <h4>2 credits for API call and 5 credits for each address registered for scanning every day.</h4><br/> <p>This method is used when the account has no default xpub assigned, and addresses are handled manually. It is possible to pair any number of blockchain address to the account.</p> 
    # @param id Account ID
    # @param address Blockchain address
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index Destination tag or memo attribute for XRP or XLM addresses
    # @return [Address]
    def assign_address(id, address, opts = {})
      data, _status_code, _headers = assign_address_with_http_info(id, address, opts)
      data
    end

    # Assign address for account
    # &lt;h4&gt;2 credits for API call and 5 credits for each address registered for scanning every day.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is used when the account has no default xpub assigned, and addresses are handled manually. It is possible to pair any number of blockchain address to the account.&lt;/p&gt; 
    # @param id Account ID
    # @param address Blockchain address
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index Destination tag or memo attribute for XRP or XLM addresses
    # @return [Array<(Address, Integer, Hash)>] Address data, response status code and response headers
    def assign_address_with_http_info(id, address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainAccountApi.assign_address ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling OffChainAccountApi.assign_address"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling OffChainAccountApi.assign_address"
      end
      # resource path
      local_var_path = '/v3/offchain/account/{id}/address/{address}'.sub('{' + 'id' + '}', id.to_s).sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'index'] = opts[:'index'] if !opts[:'index'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Address' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainAccountApi#assign_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create new deposit address
    # <h4>2 credits per API call and 5 credits for each address registered for scanning every day. If address is FLOW or FUSD, additional 3000 credits are consumed - see <a href=\"#operation/FlowGenerateAddress\">Flow address generation.</a></h4><br/> <p>Create a new deposit address for the account. This method associates public blockchain's ledger address with the account on Tatum's private ledger.<br/> It is possible to generate multiple blockchain addresses for the same ledger account. By this, it is possible to aggregate various blockchain transactions from different addresses into the same account. Depending on the currency of an account, this method will either generate a public address for Bitcoin, Bitcoin Cash, Litecoin or Ethereum, DestinationTag in case of XRP or message in case of XLM. More information about supported blockchains and address types can be found <a href=\"#operation/createAccount\">here</a>.<br/> Addresses are generated in the natural order of the Extended public key provided in the account. Derivation index is the representation of that order - starts from 0 and ends at 2^31. When a new address is generated, the last not used index is used to generate an address. It is possible to skip some of the addresses to the different index, which means all the skipped addresses will no longer be used. </p> 
    # @param id Account ID
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index &lt;p&gt;Derivation path index for specific address. If not present, last used index for given xpub of account + 1 is used. We recommend not to pass this value manually, since when some of the indexes are skipped, it is not possible to use them lately to generate address from it.&lt;/p&gt;
    # @return [Address]
    def generate_deposit_address(id, opts = {})
      data, _status_code, _headers = generate_deposit_address_with_http_info(id, opts)
      data
    end

    # Create new deposit address
    # &lt;h4&gt;2 credits per API call and 5 credits for each address registered for scanning every day. If address is FLOW or FUSD, additional 3000 credits are consumed - see &lt;a href&#x3D;\&quot;#operation/FlowGenerateAddress\&quot;&gt;Flow address generation.&lt;/a&gt;&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create a new deposit address for the account. This method associates public blockchain&#x27;s ledger address with the account on Tatum&#x27;s private ledger.&lt;br/&gt; It is possible to generate multiple blockchain addresses for the same ledger account. By this, it is possible to aggregate various blockchain transactions from different addresses into the same account. Depending on the currency of an account, this method will either generate a public address for Bitcoin, Bitcoin Cash, Litecoin or Ethereum, DestinationTag in case of XRP or message in case of XLM. More information about supported blockchains and address types can be found &lt;a href&#x3D;\&quot;#operation/createAccount\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; Addresses are generated in the natural order of the Extended public key provided in the account. Derivation index is the representation of that order - starts from 0 and ends at 2^31. When a new address is generated, the last not used index is used to generate an address. It is possible to skip some of the addresses to the different index, which means all the skipped addresses will no longer be used. &lt;/p&gt; 
    # @param id Account ID
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index &lt;p&gt;Derivation path index for specific address. If not present, last used index for given xpub of account + 1 is used. We recommend not to pass this value manually, since when some of the indexes are skipped, it is not possible to use them lately to generate address from it.&lt;/p&gt;
    # @return [Array<(Address, Integer, Hash)>] Address data, response status code and response headers
    def generate_deposit_address_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainAccountApi.generate_deposit_address ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling OffChainAccountApi.generate_deposit_address"
      end
      # resource path
      local_var_path = '/v3/offchain/account/{id}/address'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'index'] = opts[:'index'] if !opts[:'index'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Address' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainAccountApi#generate_deposit_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create new deposit addresses in a batch call
    # <h4>2 credits per API call, 1 credit for every address created and 5 credits for each address registered for scanning every day. If address is FLOW or FUSD, additional 3000 credits are consumed for each address - see <a href=\"#operation/FlowGenerateAddress\">Flow address generation.<a/></h4><br/> <p>Create new deposit addressess for the account. This method associates public blockchain's ledger address with the account on Tatum's private ledger.<br/> It is possible to generate multiple blockchain addresses for the same ledger account. By this, it is possible to aggregate various blockchain transactions from different addresses into the same account. Depending on the currency of an account, this method will either generate a public address for Bitcoin, Bitcoin Cash, Litecoin or Ethereum, DestinationTag in case of XRP or message in case of XLM. More information about supported blockchains and address types can be found <a href=\"#operation/createAccount\">here</a>.<br/> Addresses are generated in the natural order of the Extended public key provided in the account. Derivation index is the representation of that order - starts from 0 and ends at 2^31. When a new address is generated, the last not used index is used to generate an address. It is possible to skip some of the addresses to the different index, which means all the skipped addresses will no longer be used. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<Address>]
    def generate_deposit_addresses_batch(body, opts = {})
      data, _status_code, _headers = generate_deposit_addresses_batch_with_http_info(body, opts)
      data
    end

    # Create new deposit addresses in a batch call
    # &lt;h4&gt;2 credits per API call, 1 credit for every address created and 5 credits for each address registered for scanning every day. If address is FLOW or FUSD, additional 3000 credits are consumed for each address - see &lt;a href&#x3D;\&quot;#operation/FlowGenerateAddress\&quot;&gt;Flow address generation.&lt;a/&gt;&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Create new deposit addressess for the account. This method associates public blockchain&#x27;s ledger address with the account on Tatum&#x27;s private ledger.&lt;br/&gt; It is possible to generate multiple blockchain addresses for the same ledger account. By this, it is possible to aggregate various blockchain transactions from different addresses into the same account. Depending on the currency of an account, this method will either generate a public address for Bitcoin, Bitcoin Cash, Litecoin or Ethereum, DestinationTag in case of XRP or message in case of XLM. More information about supported blockchains and address types can be found &lt;a href&#x3D;\&quot;#operation/createAccount\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; Addresses are generated in the natural order of the Extended public key provided in the account. Derivation index is the representation of that order - starts from 0 and ends at 2^31. When a new address is generated, the last not used index is used to generate an address. It is possible to skip some of the addresses to the different index, which means all the skipped addresses will no longer be used. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Address>, Integer, Hash)>] Array<Address> data, response status code and response headers
    def generate_deposit_addresses_batch_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainAccountApi.generate_deposit_addresses_batch ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainAccountApi.generate_deposit_addresses_batch"
      end
      # resource path
      local_var_path = '/v3/offchain/account/address/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Array<Address>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainAccountApi#generate_deposit_addresses_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all deposit addresses for account
    # <h4>1 credit per API call.</h4><br/> <p>Get all deposit addresses generated for account. It is possible to deposit funds from another blockchain address to any of associated addresses and they will be credited on the Tatum Ledger account connected to the address.</p> 
    # @param id Account ID
    # @param [Hash] opts the optional parameters
    # @return [Array<Address>]
    def get_all_deposit_addresses(id, opts = {})
      data, _status_code, _headers = get_all_deposit_addresses_with_http_info(id, opts)
      data
    end

    # Get all deposit addresses for account
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Get all deposit addresses generated for account. It is possible to deposit funds from another blockchain address to any of associated addresses and they will be credited on the Tatum Ledger account connected to the address.&lt;/p&gt; 
    # @param id Account ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Address>, Integer, Hash)>] Array<Address> data, response status code and response headers
    def get_all_deposit_addresses_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainAccountApi.get_all_deposit_addresses ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling OffChainAccountApi.get_all_deposit_addresses"
      end
      # resource path
      local_var_path = '/v3/offchain/account/{id}/address'.sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'Array<Address>' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainAccountApi#get_all_deposit_addresses\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Remove address for account
    # <h4>1 credit per API call.</h4><br/> <p>Remove blockchain address from the Ledger account. Tatum will not check for any incoming deposits on this address for this account. It will not be possible to generate the address in the future anymore.</p> 
    # @param id Account ID
    # @param address Blockchain address
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index Destination tag or memo attribute for XRP or XLM addresses
    # @return [nil]
    def remove_address(id, address, opts = {})
      remove_address_with_http_info(id, address, opts)
      nil
    end

    # Remove address for account
    # &lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Remove blockchain address from the Ledger account. Tatum will not check for any incoming deposits on this address for this account. It will not be possible to generate the address in the future anymore.&lt;/p&gt; 
    # @param id Account ID
    # @param address Blockchain address
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :index Destination tag or memo attribute for XRP or XLM addresses
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def remove_address_with_http_info(id, address, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainAccountApi.remove_address ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling OffChainAccountApi.remove_address"
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling OffChainAccountApi.remove_address"
      end
      # resource path
      local_var_path = '/v3/offchain/account/{id}/address/{address}'.sub('{' + 'id' + '}', id.to_s).sub('{' + 'address' + '}', address.to_s)

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'index'] = opts[:'index'] if !opts[:'index'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainAccountApi#remove_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
