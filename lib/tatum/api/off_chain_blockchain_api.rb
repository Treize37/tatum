=begin
#Tatum API

## Authentication  <!-- ReDoc-Inject: <security-definitions> -->

OpenAPI spec version: 3.9.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.31
=end

module Tatum
  class OffChainBlockchainApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Send ADA from Tatum ledger to blockchain
    # <h4>10 credits per API call.</h4><br/><p>Send ADA asset from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If ADA server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def ada_transfer_offchain(body, opts = {})
      data, _status_code, _headers = ada_transfer_offchain_with_http_info(body, opts)
      data
    end

    # Send ADA from Tatum ledger to blockchain
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Send ADA asset from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If ADA server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def ada_transfer_offchain_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.ada_transfer_offchain ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.ada_transfer_offchain"
      end
      # resource path
      local_var_path = '/v3/offchain/ada/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#ada_transfer_offchain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy Algo ERC20 to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy Algorand ERC20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createErc20\">Register new Algorand ERC20 token in the ledger</a> and <a href=\"#operation/AlgoDeployErc20Blockchain\">Deploy blockchain ERC-20</a>.<br/> <br/> <br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20021]
    def algo_deploy_erc20_ledger(body, opts = {})
      data, _status_code, _headers = algo_deploy_erc20_ledger_with_http_info(body, opts)
      data
    end

    # Deploy Algo ERC20 to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy Algorand ERC20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createErc20\&quot;&gt;Register new Algorand ERC20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/AlgoDeployErc20Blockchain\&quot;&gt;Deploy blockchain ERC-20&lt;/a&gt;.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20021, Integer, Hash)>] InlineResponse20021 data, response status code and response headers
    def algo_deploy_erc20_ledger_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.algo_deploy_erc20_ledger ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.algo_deploy_erc20_ledger"
      end
      # resource path
      local_var_path = '/v3/offchain/algo/erc20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20021' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#algo_deploy_erc20_ledger\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send ALGO or Erc20 from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Send ALGO or Erc20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <br/> <br/> <ul> <li>If server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Before transfer Algorand Erc20, you need to do zero transfer for preparing to be enable receive the token on recepient. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def algo_transfer(body, opts = {})
      data, _status_code, _headers = algo_transfer_with_http_info(body, opts)
      data
    end

    # Send ALGO or Erc20 from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send ALGO or Erc20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;If server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Before transfer Algorand Erc20, you need to do zero transfer for preparing to be enable receive the token on recepient. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def algo_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.algo_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.algo_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/algorand/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#algo_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Bitcoin Cash from Tatum account to address
    # <h4>10 credits per API call.</h4><br/> <p>Send Bitcoin Cash from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Bitcoin Cash server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> There are two possibilites how the transaction on the blockchain can be created: <ul> <li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li> <li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This method is a helper method, which internally wraps these steps: <ol> <li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li> <li><a href=\"#operation/BchTransferBlockchain\">Perform blockchain transaction</a> - </li> <li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li> </ol> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def bch_transfer(body, opts = {})
      data, _status_code, _headers = bch_transfer_with_http_info(body, opts)
      data
    end

    # Send Bitcoin Cash from Tatum account to address
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Bitcoin Cash from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Bitcoin Cash server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; There are two possibilites how the transaction on the blockchain can be created: &lt;ul&gt; &lt;li&gt;Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field &lt;b&gt;attr&lt;/b&gt; should be present and it should be address with the index 1 of the connected wallet.&lt;/li&gt; &lt;li&gt;Using keyPair - addresses which are used as a source of the transaction are entered manually&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This method is a helper method, which internally wraps these steps: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeWithdrawal\&quot;&gt;Store withdrawal&lt;/a&gt; - create a ledger transaction, which debits the assets on the sender account.&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/BchTransferBlockchain\&quot;&gt;Perform blockchain transaction&lt;/a&gt; - &lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/completeWithdrawal\&quot;&gt;Complete withdrawal&lt;/a&gt; - move the withdrawal to the completed state, when all of the previous steps were successful.&lt;/li&gt; &lt;/ol&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def bch_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.bch_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.bch_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/bcash/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#bch_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create BNB based Asset
    # <h4>2 credits per API call.</h4><br/><p> <p>Create BNB-based Asset in Tatum Ledger. Asset must be created and configured on Binance blockhain before. Please see <a href=\"https://docs.binance.org/tokens.html\" targer=\"_blank\">Create Asset</a>. This API call will create Tatum internal Virtual Currency. It is possible to create Tatum ledger accounts with off-chain support. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def bnb_asset_offchain(body, opts = {})
      bnb_asset_offchain_with_http_info(body, opts)
      nil
    end

    # Create BNB based Asset
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Create BNB-based Asset in Tatum Ledger. Asset must be created and configured on Binance blockhain before. Please see &lt;a href&#x3D;\&quot;https://docs.binance.org/tokens.html\&quot; targer&#x3D;\&quot;_blank\&quot;&gt;Create Asset&lt;/a&gt;. This API call will create Tatum internal Virtual Currency. It is possible to create Tatum ledger accounts with off-chain support. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def bnb_asset_offchain_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.bnb_asset_offchain ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.bnb_asset_offchain"
      end
      # resource path
      local_var_path = '/v3/offchain/bnb/asset'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#bnb_asset_offchain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send BNB from Tatum ledger to blockchain
    # <h4>10 credits per API call.</h4><br/><p> <p>Send BNB or BNB Asset from account to account. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If BNB server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def bnb_transfer(body, opts = {})
      data, _status_code, _headers = bnb_transfer_with_http_info(body, opts)
      data
    end

    # Send BNB from Tatum ledger to blockchain
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Send BNB or BNB Asset from account to account. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If BNB server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def bnb_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.bnb_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.bnb_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/bnb/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#bnb_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy BSC BEP20 Smart Contract to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy BSC BEP20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createBep20\">Register new BEP20 token in the ledger</a> and <a href=\"#operation/BscDeployBep20Blockchain\">Deploy blockchain BEP20</a>.<br/> <br/> <br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20020]
    def bsc_deploy_bep20(body, opts = {})
      data, _status_code, _headers = bsc_deploy_bep20_with_http_info(body, opts)
      data
    end

    # Deploy BSC BEP20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy BSC BEP20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createBep20\&quot;&gt;Register new BEP20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/BscDeployBep20Blockchain\&quot;&gt;Deploy blockchain BEP20&lt;/a&gt;.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def bsc_deploy_bep20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.bsc_deploy_bep20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.bsc_deploy_bep20"
      end
      # resource path
      local_var_path = '/v3/offchain/bsc/bep20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#bsc_deploy_bep20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send BSC or BEP20 from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Send BSC or BEP20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <br/> <br/> <ul> <li>If BSC server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def bsc_or_bep_transfer(body, opts = {})
      data, _status_code, _headers = bsc_or_bep_transfer_with_http_info(body, opts)
      data
    end

    # Send BSC or BEP20 from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send BSC or BEP20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;If BSC server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def bsc_or_bep_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.bsc_or_bep_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.bsc_or_bep_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/bsc/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#bsc_or_bep_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Bitcoin from Tatum account to address
    # <h4>2 credits per API call.</h4><br/> <p>Send Bitcoin from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Bitcoin server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> There are two possibilites how the transaction on the blockchain can be created: <ul> <li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li> <li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This method is a helper method, which internally wraps these steps: <ol> <li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li> <li><a href=\"#operation/BtcTransferBlockchain\">Perform blockchain transaction</a> - </li> <li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li> </ol> When some of the steps fails, <a href=\"#operation/cancelInProgressWithdrawal\">Cancel withdrawal</a> operation is used, which cancels withdrawal and creates refund transaction to the sender account.</li> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def btc_transfer(body, opts = {})
      data, _status_code, _headers = btc_transfer_with_http_info(body, opts)
      data
    end

    # Send Bitcoin from Tatum account to address
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Bitcoin from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Bitcoin server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; There are two possibilites how the transaction on the blockchain can be created: &lt;ul&gt; &lt;li&gt;Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field &lt;b&gt;attr&lt;/b&gt; should be present and it should be address with the index 1 of the connected wallet.&lt;/li&gt; &lt;li&gt;Using keyPair - addresses which are used as a source of the transaction are entered manually&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This method is a helper method, which internally wraps these steps: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeWithdrawal\&quot;&gt;Store withdrawal&lt;/a&gt; - create a ledger transaction, which debits the assets on the sender account.&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/BtcTransferBlockchain\&quot;&gt;Perform blockchain transaction&lt;/a&gt; - &lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/completeWithdrawal\&quot;&gt;Complete withdrawal&lt;/a&gt; - move the withdrawal to the completed state, when all of the previous steps were successful.&lt;/li&gt; &lt;/ol&gt; When some of the steps fails, &lt;a href&#x3D;\&quot;#operation/cancelInProgressWithdrawal\&quot;&gt;Cancel withdrawal&lt;/a&gt; operation is used, which cancels withdrawal and creates refund transaction to the sender account.&lt;/li&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def btc_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.btc_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.btc_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/bitcoin/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#btc_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy Celo ERC-20 Smart Contract to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy Celo ERC-20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createCeloErc20\">Register new Celo ERC-20 token in the ledger</a> and <a href=\"#operation/CeloDeployErc20\">Deploy blockchain ERC-20</a>.<br/> <br/> <br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20020]
    def celo_deploy_erc20_ledger(body, opts = {})
      data, _status_code, _headers = celo_deploy_erc20_ledger_with_http_info(body, opts)
      data
    end

    # Deploy Celo ERC-20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy Celo ERC-20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createCeloErc20\&quot;&gt;Register new Celo ERC-20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/CeloDeployErc20\&quot;&gt;Deploy blockchain ERC-20&lt;/a&gt;.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def celo_deploy_erc20_ledger_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.celo_deploy_erc20_ledger ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.celo_deploy_erc20_ledger"
      end
      # resource path
      local_var_path = '/v3/offchain/celo/erc20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#celo_deploy_erc20_ledger\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Celo, cUSD, cEUR or ERC-20 from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Send Celo or ERC-20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <br/> <br/> <ul> <li>If Celo server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def celo_or_erc20_transfer(body, opts = {})
      data, _status_code, _headers = celo_or_erc20_transfer_with_http_info(body, opts)
      data
    end

    # Send Celo, cUSD, cEUR or ERC-20 from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Celo or ERC-20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;If Celo server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def celo_or_erc20_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.celo_or_erc20_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.celo_or_erc20_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/celo/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#celo_or_erc20_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new BEP20 token in the ledger
    # <h4>2 credits per API call.</h4><br/> <p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p> <p>First step to create new BEP20 token with given supply on BSC blockchain with support of Tatum's private ledger.<br/> <br/> <br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of BEP20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with BEP20 token name as account's currency.<br/> Newly created account is frozen until the specific BEP20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create BEP20 smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/registerErc20Token\">Register BEP20 token</a> - creates a virtual currency within Tatum</li> <li><a href=\"#operation/BscDeployErc20Blockchain\">Deploy BEP20 smart contract</a> - create new BEP20 smart contract on the blockchain</li> <li><a href=\"#operation/storeTokenAddress\">Store BEP20 smart contract address</a> - link newly created BEP20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for BEP20 Tatum accounts</li> </ol> There is a helper method <a href=\"#operation/EthDeployErc20\">Deploy BSC BEP20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def create_bep20(body, opts = {})
      data, _status_code, _headers = create_bep20_with_http_info(body, opts)
      data
    end

    # Register new BEP20 token in the ledger
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is deprecated. Use &lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register token&lt;/a&gt; instead.&lt;/p&gt; &lt;p&gt;First step to create new BEP20 token with given supply on BSC blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of BEP20 token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with BEP20 token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific BEP20 smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create BEP20 smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register BEP20 token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/BscDeployErc20Blockchain\&quot;&gt;Deploy BEP20 smart contract&lt;/a&gt; - create new BEP20 smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Store BEP20 smart contract address&lt;/a&gt; - link newly created BEP20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for BEP20 Tatum accounts&lt;/li&gt; &lt;/ol&gt; There is a helper method &lt;a href&#x3D;\&quot;#operation/EthDeployErc20\&quot;&gt;Deploy BSC BEP20 Smart Contract to Blockchain and Ledger&lt;/a&gt;, which wraps first 2 steps into 1 method.&lt;br/&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def create_bep20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.create_bep20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.create_bep20"
      end
      # resource path
      local_var_path = '/v3/offchain/bsc/bep20'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#create_bep20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new Celo ERC-20 token in the ledger
    # <h4>2 credits per API call.</h4><br/> <p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p> <p>First step to create new ERC-20 token with given supply on Celo blockchain with support of Tatum's private ledger.<br/> <br/> <br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of ERC-20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with ERC-20 token name as account's currency.<br/> Newly created account is frozen until the specific ERC-20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create ERC-20 smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/registerErc20Token\">Register Celo ERC-20 token</a> - creates a virtual currency within Tatum</li> <li><a href=\"#operation/CeloDeployErc20\">Deploy Celo ERC-20 smart contract</a> - create new ERC-20 smart contract on the blockchain</li> <li><a href=\"#operation/storeTokenAddress\">Store Celo ERC-20 smart contract address</a> - link newly created ERC-20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC-20 Tatum accounts</li> </ol> There is a helper method <a href=\"#operation/CeloDeployErc20Ledger\">Deploy Celo ERC-20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def create_celo_erc20(body, opts = {})
      data, _status_code, _headers = create_celo_erc20_with_http_info(body, opts)
      data
    end

    # Register new Celo ERC-20 token in the ledger
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is deprecated. Use &lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register token&lt;/a&gt; instead.&lt;/p&gt; &lt;p&gt;First step to create new ERC-20 token with given supply on Celo blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of ERC-20 token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with ERC-20 token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific ERC-20 smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create ERC-20 smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register Celo ERC-20 token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/CeloDeployErc20\&quot;&gt;Deploy Celo ERC-20 smart contract&lt;/a&gt; - create new ERC-20 smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Store Celo ERC-20 smart contract address&lt;/a&gt; - link newly created ERC-20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC-20 Tatum accounts&lt;/li&gt; &lt;/ol&gt; There is a helper method &lt;a href&#x3D;\&quot;#operation/CeloDeployErc20Ledger\&quot;&gt;Deploy Celo ERC-20 Smart Contract to Blockchain and Ledger&lt;/a&gt;, which wraps first 2 steps into 1 method.&lt;br/&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def create_celo_erc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.create_celo_erc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.create_celo_erc20"
      end
      # resource path
      local_var_path = '/v3/offchain/celo/erc20'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#create_celo_erc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new ERC20 token in the ledger
    # <h4>2 credits per API call.</h4><br/> <p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p> <p>First step to create new ERC20 token with given supply on Ethereum blockchain with support of Tatum's private ledger.<br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of ERC20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with ERC20 token name as account's currency.<br/> Newly created account is frozen until the specific ERC20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create ERC20 smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/registerErc20Token\">Create ERC20 token</a> - creates a virtual currency within Tatum</li> <li><a href=\"#operation/EthDeployErc20Blockchain\">Deploy ERC20 smart contract</a> - create new ERC20 smart contract on the blockchain</li> <li><a href=\"#operation/storeTokenAddress\">Store ERC20 smart contract address</a> - link newly created ERC20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC20 Tatum accounts</li> </ol> There is a helper method <a href=\"#operation/EthDeployErc20\">Deploy Ethereum ERC20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def create_erc20(body, opts = {})
      data, _status_code, _headers = create_erc20_with_http_info(body, opts)
      data
    end

    # Register new ERC20 token in the ledger
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is deprecated. Use &lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register token&lt;/a&gt; instead.&lt;/p&gt; &lt;p&gt;First step to create new ERC20 token with given supply on Ethereum blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of ERC20 token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with ERC20 token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific ERC20 smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create ERC20 smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Create ERC20 token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/EthDeployErc20Blockchain\&quot;&gt;Deploy ERC20 smart contract&lt;/a&gt; - create new ERC20 smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Store ERC20 smart contract address&lt;/a&gt; - link newly created ERC20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC20 Tatum accounts&lt;/li&gt; &lt;/ol&gt; There is a helper method &lt;a href&#x3D;\&quot;#operation/EthDeployErc20\&quot;&gt;Deploy Ethereum ERC20 Smart Contract to Blockchain and Ledger&lt;/a&gt;, which wraps first 2 steps into 1 method.&lt;br/&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def create_erc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.create_erc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.create_erc20"
      end
      # resource path
      local_var_path = '/v3/offchain/ethereum/erc20'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#create_erc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new ONE HRM20 token in the ledger
    # <h4>2 credits per API call.</h4><br/> <p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p> <p>First step to create new HRM20 token with given supply on ONE blockchain with support of Tatum's private ledger.<br/> <br/> <br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of HRM20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with HRM20 token name as account's currency.<br/> Newly created account is frozen until the specific HRM20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create HRM20 smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/registerErc20Token\">Register HRM20 token</a> - creates a virtual currency within Tatum</li> <li><a href=\"#operation/Erc20Deploy\">Deploy HRM20 smart contract</a> - create new HRM20 smart contract on the blockchain</li> <li><a href=\"#operation/storeTokenAddress\">Store HRM20 smart contract address</a> - link newly created HRM20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for HRM20 Tatum accounts</li> </ol> There is a helper method <a href=\"#operation/Erc20Deploy\">Deploy ONE HRM20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def create_hrm20(body, opts = {})
      data, _status_code, _headers = create_hrm20_with_http_info(body, opts)
      data
    end

    # Register new ONE HRM20 token in the ledger
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is deprecated. Use &lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register token&lt;/a&gt; instead.&lt;/p&gt; &lt;p&gt;First step to create new HRM20 token with given supply on ONE blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of HRM20 token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with HRM20 token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific HRM20 smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create HRM20 smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register HRM20 token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/Erc20Deploy\&quot;&gt;Deploy HRM20 smart contract&lt;/a&gt; - create new HRM20 smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Store HRM20 smart contract address&lt;/a&gt; - link newly created HRM20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for HRM20 Tatum accounts&lt;/li&gt; &lt;/ol&gt; There is a helper method &lt;a href&#x3D;\&quot;#operation/Erc20Deploy\&quot;&gt;Deploy ONE HRM20 Smart Contract to Blockchain and Ledger&lt;/a&gt;, which wraps first 2 steps into 1 method.&lt;br/&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def create_hrm20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.create_hrm20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.create_hrm20"
      end
      # resource path
      local_var_path = '/v3/offchain/one/hrm20'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#create_hrm20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new TRC-10/20 token in the ledger
    # <h4>10 credits per API call.</h4><br/> <p>First step to create new TRC 10/20 token with given supply on the Tron blockchain with support of Tatum's private ledger.<br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of TRC 10/20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with TRC 10/20 token name as account's currency.<br/> Newly created account is frozen until the specific TRC 10/20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create TRC 10/20 smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/createTrc\">Create TRC 10/20 token</a> - creates a virtual currency within Tatum</li> <li><a href=\"#operation/TronCreateTrc20\">Deploy TRC 10</a> or <a href=\"#operation/TronCreateTrc10\">TRC 20 smart contract</a> - create new TRC 10/20 smart contract on the blockchain</li> <li><a href=\"#operation/storeTrcAddress\">Store TRC 10/20 smart contract address</a> - link newly created TRC 10/20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for TRC 10/20 Tatum accounts</li> </ol> There is a helper method <a href=\"#operation/TronDeployTrc\">Deploy TRC 10/20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def create_trc(body, opts = {})
      data, _status_code, _headers = create_trc_with_http_info(body, opts)
      data
    end

    # Register new TRC-10/20 token in the ledger
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;First step to create new TRC 10/20 token with given supply on the Tron blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of TRC 10/20 token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with TRC 10/20 token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific TRC 10/20 smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create TRC 10/20 smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/createTrc\&quot;&gt;Create TRC 10/20 token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/TronCreateTrc20\&quot;&gt;Deploy TRC 10&lt;/a&gt; or &lt;a href&#x3D;\&quot;#operation/TronCreateTrc10\&quot;&gt;TRC 20 smart contract&lt;/a&gt; - create new TRC 10/20 smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTrcAddress\&quot;&gt;Store TRC 10/20 smart contract address&lt;/a&gt; - link newly created TRC 10/20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for TRC 10/20 Tatum accounts&lt;/li&gt; &lt;/ol&gt; There is a helper method &lt;a href&#x3D;\&quot;#operation/TronDeployTrc\&quot;&gt;Deploy TRC 10/20 Smart Contract to Blockchain and Ledger&lt;/a&gt;, which wraps first 2 steps into 1 method.&lt;br/&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def create_trc_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.create_trc ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.create_trc"
      end
      # resource path
      local_var_path = '/v3/offchain/tron/trc'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#create_trc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new XDC ERC20 token in the ledger
    # <h4>2 credits per API call.</h4><br/> <p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p> <p>First step to create new ERC20 token with given supply on XDC blockchain with support of Tatum's private ledger.<br/> <br/> <br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of ERC20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with ERC20 token name as account's currency.<br/> Newly created account is frozen until the specific ERC20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create ERC20 smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/registerErc20Token\">Register ERC20 token</a> - creates a virtual currency within Tatum</li> <li><a href=\"#operation/Erc20Deploy\">Deploy ERC20 smart contract</a> - create new ERC20 smart contract on the blockchain</li> <li><a href=\"#operation/storeTokenAddress\">Store ERC20 smart contract address</a> - link newly created ERC20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC20 Tatum accounts</li> </ol> There is a helper method <a href=\"#operation/Erc20Deploy\">Deploy XDC ERC20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def create_xdc20(body, opts = {})
      data, _status_code, _headers = create_xdc20_with_http_info(body, opts)
      data
    end

    # Register new XDC ERC20 token in the ledger
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;This method is deprecated. Use &lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register token&lt;/a&gt; instead.&lt;/p&gt; &lt;p&gt;First step to create new ERC20 token with given supply on XDC blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of ERC20 token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with ERC20 token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific ERC20 smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create ERC20 smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register ERC20 token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/Erc20Deploy\&quot;&gt;Deploy ERC20 smart contract&lt;/a&gt; - create new ERC20 smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Store ERC20 smart contract address&lt;/a&gt; - link newly created ERC20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC20 Tatum accounts&lt;/li&gt; &lt;/ol&gt; There is a helper method &lt;a href&#x3D;\&quot;#operation/Erc20Deploy\&quot;&gt;Deploy XDC ERC20 Smart Contract to Blockchain and Ledger&lt;/a&gt;, which wraps first 2 steps into 1 method.&lt;br/&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def create_xdc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.create_xdc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.create_xdc20"
      end
      # resource path
      local_var_path = '/v3/offchain/xdc/erc20'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#create_xdc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Dogecoin from Tatum account to address
    # <h4>4 credits per API call.</h4><br/> <p>Send Dogecoin from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Dogecoin server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> There are two possibilites how the transaction on the blockchain can be created: <ul> <li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li> <li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This method is a helper method, which internally wraps these steps: <ol> <li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li> <li><a href=\"#operation/DogeTransferBlockchain\">Perform blockchain transaction</a> - </li> <li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li> </ol> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def doge_transfer(body, opts = {})
      data, _status_code, _headers = doge_transfer_with_http_info(body, opts)
      data
    end

    # Send Dogecoin from Tatum account to address
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Dogecoin from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Dogecoin server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; There are two possibilites how the transaction on the blockchain can be created: &lt;ul&gt; &lt;li&gt;Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field &lt;b&gt;attr&lt;/b&gt; should be present and it should be address with the index 1 of the connected wallet.&lt;/li&gt; &lt;li&gt;Using keyPair - addresses which are used as a source of the transaction are entered manually&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This method is a helper method, which internally wraps these steps: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeWithdrawal\&quot;&gt;Store withdrawal&lt;/a&gt; - create a ledger transaction, which debits the assets on the sender account.&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/DogeTransferBlockchain\&quot;&gt;Perform blockchain transaction&lt;/a&gt; - &lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/completeWithdrawal\&quot;&gt;Complete withdrawal&lt;/a&gt; - move the withdrawal to the completed state, when all of the previous steps were successful.&lt;/li&gt; &lt;/ol&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def doge_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.doge_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.doge_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/dogecoin/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#doge_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send EGLD from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Send EGLD from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <br/> <br/> <ul> <li>If server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def egld_transfer(body, opts = {})
      data, _status_code, _headers = egld_transfer_with_http_info(body, opts)
      data
    end

    # Send EGLD from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send EGLD from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;If server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def egld_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.egld_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.egld_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/egld/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#egld_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy Ethereum ERC20 Smart Contract to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy Ethereum ERC20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createErc20\">Register new ERC20 token in the ledger</a> and <a href=\"#operation/EthDeployErc20Blockchain\">Deploy blockchain ERC20</a>.<br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20020]
    def eth_deploy_erc20(body, opts = {})
      data, _status_code, _headers = eth_deploy_erc20_with_http_info(body, opts)
      data
    end

    # Deploy Ethereum ERC20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy Ethereum ERC20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createErc20\&quot;&gt;Register new ERC20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/EthDeployErc20Blockchain\&quot;&gt;Deploy blockchain ERC20&lt;/a&gt;.&lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def eth_deploy_erc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.eth_deploy_erc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.eth_deploy_erc20"
      end
      # resource path
      local_var_path = '/v3/offchain/ethereum/erc20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#eth_deploy_erc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Ethereum from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/><p>Send Ethereum from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Ethereum server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def eth_transfer(body, opts = {})
      data, _status_code, _headers = eth_transfer_with_http_info(body, opts)
      data
    end

    # Send Ethereum from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Send Ethereum from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Ethereum server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def eth_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.eth_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.eth_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/ethereum/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#eth_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Transfer Ethereum ERC20 from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Transfer Ethereum ERC20 Smart Contract Tokens from Tatum account to blockchain address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Ethereum server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def eth_transfer_erc20(body, opts = {})
      data, _status_code, _headers = eth_transfer_erc20_with_http_info(body, opts)
      data
    end

    # Transfer Ethereum ERC20 from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Transfer Ethereum ERC20 Smart Contract Tokens from Tatum account to blockchain address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Ethereum server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def eth_transfer_erc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.eth_transfer_erc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.eth_transfer_erc20"
      end
      # resource path
      local_var_path = '/v3/offchain/ethereum/erc20/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#eth_transfer_erc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Flow or FUSD from Tatum account to address
    # <h4>100 credits per API call. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.</h4><br/> <p>Send Flow or FUSD from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Flow server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> There are two possibilites how the transaction on the blockchain can be created: <ul> <li>Using mnemonic and index - private key is generated based on the index in the mnemonic.</li> <li>Using secret - private keys is entered manually.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This method is a helper method, which internally wraps these steps: <ol> <li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li> <li><a href=\"#operation/FlowTransferBlockchain\">Perform blockchain transaction</a> - </li> <li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li> </ol> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def flow_transfer(body, opts = {})
      data, _status_code, _headers = flow_transfer_with_http_info(body, opts)
      data
    end

    # Send Flow or FUSD from Tatum account to address
    # &lt;h4&gt;100 credits per API call. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Flow or FUSD from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Flow server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; There are two possibilites how the transaction on the blockchain can be created: &lt;ul&gt; &lt;li&gt;Using mnemonic and index - private key is generated based on the index in the mnemonic.&lt;/li&gt; &lt;li&gt;Using secret - private keys is entered manually.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This method is a helper method, which internally wraps these steps: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeWithdrawal\&quot;&gt;Store withdrawal&lt;/a&gt; - create a ledger transaction, which debits the assets on the sender account.&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/FlowTransferBlockchain\&quot;&gt;Perform blockchain transaction&lt;/a&gt; - &lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/completeWithdrawal\&quot;&gt;Complete withdrawal&lt;/a&gt; - move the withdrawal to the completed state, when all of the previous steps were successful.&lt;/li&gt; &lt;/ol&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def flow_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.flow_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.flow_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/flow/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#flow_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy Kcs ERC20 Smart Contract to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy Kcs ERC20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createErc20\">Register new Kcs ERC20 token in the ledger</a> and <a href=\"#operation/KcsDeployErc20Blockchain\">Deploy blockchain ERC-20</a>.<br/> <br/> <br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20020]
    def kcs_deploy_erc20_ledger(body, opts = {})
      data, _status_code, _headers = kcs_deploy_erc20_ledger_with_http_info(body, opts)
      data
    end

    # Deploy Kcs ERC20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy Kcs ERC20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createErc20\&quot;&gt;Register new Kcs ERC20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/KcsDeployErc20Blockchain\&quot;&gt;Deploy blockchain ERC-20&lt;/a&gt;.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def kcs_deploy_erc20_ledger_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.kcs_deploy_erc20_ledger ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.kcs_deploy_erc20_ledger"
      end
      # resource path
      local_var_path = '/v3/offchain/kcs/erc20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#kcs_deploy_erc20_ledger\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send KCS from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/><p>Send KCS or ERC20 on KCS from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If KCS server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def kcs_transfer(body, opts = {})
      data, _status_code, _headers = kcs_transfer_with_http_info(body, opts)
      data
    end

    # Send KCS from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Send KCS or ERC20 on KCS from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If KCS server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def kcs_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.kcs_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.kcs_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/kcs/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#kcs_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Litecoin from Tatum account to address
    # <h4>10 credits per API call.</h4><br/> <p>Send Litecoin from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Litecoin server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> There are two possibilites how the transaction on the blockchain can be created: <ul> <li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li> <li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This method is a helper method, which internally wraps these steps: <ol> <li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li> <li><a href=\"#operation/LtcTransferBlockchain\">Perform blockchain transaction</a> - </li> <li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li> </ol> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.</p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def ltc_transfer(body, opts = {})
      data, _status_code, _headers = ltc_transfer_with_http_info(body, opts)
      data
    end

    # Send Litecoin from Tatum account to address
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send Litecoin from Tatum account to address. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Litecoin server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; There are two possibilites how the transaction on the blockchain can be created: &lt;ul&gt; &lt;li&gt;Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits which are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field &lt;b&gt;attr&lt;/b&gt; should be present and it should be address with the index 1 of the connected wallet.&lt;/li&gt; &lt;li&gt;Using keyPair - addresses which are used as a source of the transaction are entered manually&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This method is a helper method, which internally wraps these steps: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeWithdrawal\&quot;&gt;Store withdrawal&lt;/a&gt; - create a ledger transaction, which debits the assets on the sender account.&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/LtcTransferBlockchain\&quot;&gt;Perform blockchain transaction&lt;/a&gt; - &lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/completeWithdrawal\&quot;&gt;Complete withdrawal&lt;/a&gt; - move the withdrawal to the completed state, when all of the previous steps were successful.&lt;/li&gt; &lt;/ol&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.&lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def ltc_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.ltc_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.ltc_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/litecoin/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#ltc_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Estimate ledger to blockchain transaction fee
    # <h4>2 credits per API call.</h4><br/> <p>Estimate current transaction fee for ledger to blockchain transaction.<br/> Supported blockchains: <ul> <li>Bitcoin</li> <li>Litecoin</li> <li>Dogecoin</li> </ul> </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [FeeBtc]
    def offchain_estimate_fee(body, opts = {})
      data, _status_code, _headers = offchain_estimate_fee_with_http_info(body, opts)
      data
    end

    # Estimate ledger to blockchain transaction fee
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Estimate current transaction fee for ledger to blockchain transaction.&lt;br/&gt; Supported blockchains: &lt;ul&gt; &lt;li&gt;Bitcoin&lt;/li&gt; &lt;li&gt;Litecoin&lt;/li&gt; &lt;li&gt;Dogecoin&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FeeBtc, Integer, Hash)>] FeeBtc data, response status code and response headers
    def offchain_estimate_fee_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.offchain_estimate_fee ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.offchain_estimate_fee"
      end
      # resource path
      local_var_path = '/v3/offchain/blockchain/estimate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'FeeBtc' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#offchain_estimate_fee\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy ONE HRM20 Smart Contract to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy ONE HRM20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createHrm20\">Register new HRM20 token in the ledger</a> and <a href=\"#operation/Erc20Deploy\">Deploy blockchain HRM20</a>.<br/> <br/> <br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :shard_id Shard to operate on (default to 0)
    # @return [InlineResponse20020]
    def one_deploy_hrm20(body, opts = {})
      data, _status_code, _headers = one_deploy_hrm20_with_http_info(body, opts)
      data
    end

    # Deploy ONE HRM20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy ONE HRM20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createHrm20\&quot;&gt;Register new HRM20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/Erc20Deploy\&quot;&gt;Deploy blockchain HRM20&lt;/a&gt;.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :shard_id Shard to operate on
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def one_deploy_hrm20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.one_deploy_hrm20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.one_deploy_hrm20"
      end
      # resource path
      local_var_path = '/v3/offchain/one/hrm20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'shardID'] = opts[:'shard_id'] if !opts[:'shard_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#one_deploy_hrm20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send ONE or HRM-20 from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Send ONE or HRM20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <br/> <br/> <ul> <li>If ONE server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :shard_id Shard to operate on (default to 0)
    # @return [InlineResponse20019]
    def one_transfer(body, opts = {})
      data, _status_code, _headers = one_transfer_with_http_info(body, opts)
      data
    end

    # Send ONE or HRM-20 from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send ONE or HRM20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;If ONE server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @option opts [BigDecimal] :shard_id Shard to operate on
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def one_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.one_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.one_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/one/transfer'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'shardID'] = opts[:'shard_id'] if !opts[:'shard_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#one_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send MATIC from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/><p>Send MATIC or ERC20 on Polygon from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Polygon server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def polygon_transfer(body, opts = {})
      data, _status_code, _headers = polygon_transfer_with_http_info(body, opts)
      data
    end

    # Send MATIC from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Send MATIC or ERC20 on Polygon from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Polygon server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def polygon_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.polygon_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.polygon_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/polygon/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#polygon_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register new token in the ledger
    # <h4>2 credits per API call.</h4><br/> <p>First step to create new ERC|HRM|BEP-20 token with given supply on chosen blockchain with support of Tatum's private ledger.<br/> <br/> <br/> This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/> The whole supply of token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with token name as account's currency.<br/> Newly created account is frozen until the specific smart contract address is linked with the Tatum virtual currency, representing the token.<br/> Order of the steps to create smart contract with Tatum private ledger support: <ol> <li><a href=\"#operation/registerErc20Token\">Register token</a> - creates a virtual currency within Tatum</li> <li>Deploy smart contract - create new smart contract on the blockchain</li> <li><a href=\"#operation/storeTokenAddress\">Store smart contract address</a> - link newly created smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for Tatum accounts</li> </ol> Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub. </p> 
    # @param body 
    # @param chain Blockchain to work with
    # @param [Hash] opts the optional parameters
    # @return [Erc20Response]
    def register_erc20_token(body, chain, opts = {})
      data, _status_code, _headers = register_erc20_token_with_http_info(body, chain, opts)
      data
    end

    # Register new token in the ledger
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;First step to create new ERC|HRM|BEP-20 token with given supply on chosen blockchain with support of Tatum&#x27;s private ledger.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; This method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.&lt;br/&gt; The whole supply of token is stored in the customer&#x27;s newly created account. Then it is possible to create new Tatum accounts with token name as account&#x27;s currency.&lt;br/&gt; Newly created account is frozen until the specific smart contract address is linked with the Tatum virtual currency, representing the token.&lt;br/&gt; Order of the steps to create smart contract with Tatum private ledger support: &lt;ol&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/registerErc20Token\&quot;&gt;Register token&lt;/a&gt; - creates a virtual currency within Tatum&lt;/li&gt; &lt;li&gt;Deploy smart contract - create new smart contract on the blockchain&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Store smart contract address&lt;/a&gt; - link newly created smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for Tatum accounts&lt;/li&gt; &lt;/ol&gt; Address on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account&#x27;s xpub. &lt;/p&gt; 
    # @param body 
    # @param chain Blockchain to work with
    # @param [Hash] opts the optional parameters
    # @return [Array<(Erc20Response, Integer, Hash)>] Erc20Response data, response status code and response headers
    def register_erc20_token_with_http_info(body, chain, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.register_erc20_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.register_erc20_token"
      end
      # verify the required parameter 'chain' is set
      if @api_client.config.client_side_validation && chain.nil?
        fail ArgumentError, "Missing the required parameter 'chain' when calling OffChainBlockchainApi.register_erc20_token"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ETH', 'CELO', 'MATIC', 'KCS', 'BSC', 'ONE', 'XDC'].include?(chain)
        fail ArgumentError, "invalid value for 'chain', must be one of ETH, CELO, MATIC, KCS, BSC, ONE, XDC"
      end
      # resource path
      local_var_path = '/v3/offchain/token/{chain}'.sub('{' + 'chain' + '}', chain.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'Erc20Response' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#register_erc20_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Set Celo ERC-20 token contract address
    # <h4>2 credits per API call.</h4><br/> <b>This method is deprecated. Please use <a href=\"#operation/storeTokenAddress\">Set Token address</a>.</b><br/> <p>Set contract address of ERC-20 token. This must be done in order to communicate with ERC-20 smart contract. <br/> <br/> After creating and deploying ERC-20 token to CELO blockchain, smart contract address is generated and must be set within Tatum. Otherwise Tatum platform will not be able to detect incoming deposits of ERC-20 and do withdrawals from Tatum accounts to other blockchain addresses.</p> 
    # @param address ERC-20 contract address
    # @param name ERC-20 symbol name.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def store_celo_erc20_address(address, name, opts = {})
      store_celo_erc20_address_with_http_info(address, name, opts)
      nil
    end

    # Set Celo ERC-20 token contract address
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;b&gt;This method is deprecated. Please use &lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Set Token address&lt;/a&gt;.&lt;/b&gt;&lt;br/&gt; &lt;p&gt;Set contract address of ERC-20 token. This must be done in order to communicate with ERC-20 smart contract. &lt;br/&gt; &lt;br/&gt; After creating and deploying ERC-20 token to CELO blockchain, smart contract address is generated and must be set within Tatum. Otherwise Tatum platform will not be able to detect incoming deposits of ERC-20 and do withdrawals from Tatum accounts to other blockchain addresses.&lt;/p&gt; 
    # @param address ERC-20 contract address
    # @param name ERC-20 symbol name.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def store_celo_erc20_address_with_http_info(address, name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.store_celo_erc20_address ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling OffChainBlockchainApi.store_celo_erc20_address"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling OffChainBlockchainApi.store_celo_erc20_address"
      end
      # resource path
      local_var_path = '/v3/offchain/celo/erc20/{name}/{address}'.sub('{' + 'address' + '}', address.to_s).sub('{' + 'name' + '}', name.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#store_celo_erc20_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Set ERC20/BEP20/HRM20/TRC20 token contract address
    # <h4>2 credits per API call.</h4><br/> <p>Set contract address of ERC20/BEP20/HRM20 token. This must be done in order to communicate with smart contract. <br/> <br/> After creating and deploying ERC20 token to blockchain, smart contract address is generated and must be set within Tatum. In Algorand case the address should be token AssetID, for example: 55351976 Otherwise Tatum platform will not be able to detect incoming deposits of ERC20 and do withdrawals from Tatum accounts to other blockchain addresses.</p> 
    # @param address Contract address
    # @param name Symbol name.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def store_token_address(address, name, opts = {})
      store_token_address_with_http_info(address, name, opts)
      nil
    end

    # Set ERC20/BEP20/HRM20/TRC20 token contract address
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Set contract address of ERC20/BEP20/HRM20 token. This must be done in order to communicate with smart contract. &lt;br/&gt; &lt;br/&gt; After creating and deploying ERC20 token to blockchain, smart contract address is generated and must be set within Tatum. In Algorand case the address should be token AssetID, for example: 55351976 Otherwise Tatum platform will not be able to detect incoming deposits of ERC20 and do withdrawals from Tatum accounts to other blockchain addresses.&lt;/p&gt; 
    # @param address Contract address
    # @param name Symbol name.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def store_token_address_with_http_info(address, name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.store_token_address ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling OffChainBlockchainApi.store_token_address"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling OffChainBlockchainApi.store_token_address"
      end
      # resource path
      local_var_path = '/v3/offchain/token/{name}/{address}'.sub('{' + 'address' + '}', address.to_s).sub('{' + 'name' + '}', name.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#store_token_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Set TRC token contract address
    # <h4>2 credits per API call.</h4><br/> <b>This method is deprecated. Please use <a href=\"#operation/storeTokenAddress\">Set Token address</a>.</b><br/> <p>Set contract address of TRC 10/20 token. This must be done in order to communicate with TRC 10/20 smart contract. After creating and deploying TRC 10/20 token to Tron blockchain, smart contract address is generated and must be set within Tatum. Otherwise Tatum platform will not be able to detect incoming deposits of TRC 10/20 and do withdrawals from Tatum accounts to other blockchain addresses.</p> 
    # @param address TRC-10 Token ID or TRC-20 contract address
    # @param name TRC 10/20 symbol name.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def store_trc_address(address, name, opts = {})
      store_trc_address_with_http_info(address, name, opts)
      nil
    end

    # Set TRC token contract address
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;b&gt;This method is deprecated. Please use &lt;a href&#x3D;\&quot;#operation/storeTokenAddress\&quot;&gt;Set Token address&lt;/a&gt;.&lt;/b&gt;&lt;br/&gt; &lt;p&gt;Set contract address of TRC 10/20 token. This must be done in order to communicate with TRC 10/20 smart contract. After creating and deploying TRC 10/20 token to Tron blockchain, smart contract address is generated and must be set within Tatum. Otherwise Tatum platform will not be able to detect incoming deposits of TRC 10/20 and do withdrawals from Tatum accounts to other blockchain addresses.&lt;/p&gt; 
    # @param address TRC-10 Token ID or TRC-20 contract address
    # @param name TRC 10/20 symbol name.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def store_trc_address_with_http_info(address, name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.store_trc_address ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling OffChainBlockchainApi.store_trc_address"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling OffChainBlockchainApi.store_trc_address"
      end
      # resource path
      local_var_path = '/v3/offchain/tron/trc/{name}/{address}'.sub('{' + 'address' + '}', address.to_s).sub('{' + 'name' + '}', name.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#store_trc_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy Tron TRC-10/20 Smart Contract to Blockchain and Ledger
    # <h4>10 credits per API call.</h4><br/> <p>Deploy Tron TRC-10/20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createTrc\">Register new TRC-10/20 token in the ledger</a> and <a href=\"#operation/TronCreateTrc20\">Deploy blockchain TRC20</a> or <a href=\"#operation/TronCreateTrc10\">Deploy blockchain TRC10</a>.<br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20020]
    def tron_deploy_trc(body, opts = {})
      data, _status_code, _headers = tron_deploy_trc_with_http_info(body, opts)
      data
    end

    # Deploy Tron TRC-10/20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy Tron TRC-10/20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createTrc\&quot;&gt;Register new TRC-10/20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/TronCreateTrc20\&quot;&gt;Deploy blockchain TRC20&lt;/a&gt; or &lt;a href&#x3D;\&quot;#operation/TronCreateTrc10\&quot;&gt;Deploy blockchain TRC10&lt;/a&gt;.&lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def tron_deploy_trc_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.tron_deploy_trc ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.tron_deploy_trc"
      end
      # resource path
      local_var_path = '/v3/offchain/tron/trc/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#tron_deploy_trc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send Tron or TRC asset from Tatum ledger to blockchain
    # <h4>10 credits per API call.</h4><br/><p>Send Tron or TRC asset from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If Tron server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def tron_transfer_offchain(body, opts = {})
      data, _status_code, _headers = tron_transfer_offchain_with_http_info(body, opts)
      data
    end

    # Send Tron or TRC asset from Tatum ledger to blockchain
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Send Tron or TRC asset from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If Tron server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def tron_transfer_offchain_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.tron_transfer_offchain ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.tron_transfer_offchain"
      end
      # resource path
      local_var_path = '/v3/offchain/tron/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#tron_transfer_offchain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy XDC ERC20 Smart Contract to Blockchain and Ledger
    # <h4>4 credits per API call.</h4><br/> <p>Deploy XDC ERC20 Smart Contract. This is a helper method, which is combination of <a href=\"#operation/createXdc20\">Register new ERC20 token in the ledger</a> and <a href=\"#operation/Erc20Deploy\">Deploy blockchain ERC20</a>.<br/> <br/> <br/> After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20020]
    def xdc_deploy_erc20(body, opts = {})
      data, _status_code, _headers = xdc_deploy_erc20_with_http_info(body, opts)
      data
    end

    # Deploy XDC ERC20 Smart Contract to Blockchain and Ledger
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Deploy XDC ERC20 Smart Contract. This is a helper method, which is combination of &lt;a href&#x3D;\&quot;#operation/createXdc20\&quot;&gt;Register new ERC20 token in the ledger&lt;/a&gt; and &lt;a href&#x3D;\&quot;#operation/Erc20Deploy\&quot;&gt;Deploy blockchain ERC20&lt;/a&gt;.&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; After deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20020, Integer, Hash)>] InlineResponse20020 data, response status code and response headers
    def xdc_deploy_erc20_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.xdc_deploy_erc20 ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.xdc_deploy_erc20"
      end
      # resource path
      local_var_path = '/v3/offchain/xdc/erc20/deploy'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20020' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#xdc_deploy_erc20\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send XDC or ERC-20 from Tatum ledger to blockchain
    # <h4>4 credits per API call.</h4><br/> <p>Send XDC or ERC20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <br/> <br/> <ul> <li>If XDC server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def xdc_transfer(body, opts = {})
      data, _status_code, _headers = xdc_transfer_with_http_info(body, opts)
      data
    end

    # Send XDC or ERC-20 from Tatum ledger to blockchain
    # &lt;h4&gt;4 credits per API call.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Send XDC or ERC20 from Tatum Ledger to account. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;If XDC server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def xdc_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.xdc_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.xdc_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/xdc/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#xdc_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create XLM based Asset
    # <h4>2 credits per API call.</h4><br/><p> <p>Create XLM-based Asset in Tatum Ledger. Asset must be created and configured on XLM blockhain before using <a href=\"#operation/XlmTrustLineBlockchain\">Create trust line</a>. This API call will create Tatum internal Virtual Currency. It is possible to create Tatum ledger accounts with off-chain support. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def xlm_asset_offchain(body, opts = {})
      xlm_asset_offchain_with_http_info(body, opts)
      nil
    end

    # Create XLM based Asset
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Create XLM-based Asset in Tatum Ledger. Asset must be created and configured on XLM blockhain before using &lt;a href&#x3D;\&quot;#operation/XlmTrustLineBlockchain\&quot;&gt;Create trust line&lt;/a&gt;. This API call will create Tatum internal Virtual Currency. It is possible to create Tatum ledger accounts with off-chain support. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def xlm_asset_offchain_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.xlm_asset_offchain ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.xlm_asset_offchain"
      end
      # resource path
      local_var_path = '/v3/offchain/xlm/asset'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#xlm_asset_offchain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send XLM / Asset from Tatum ledger to blockchain
    # <h4>10 credits per API call.</h4><br/><p> <p>Send XLM or XLM-based Assets from account to account. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If XLM server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def xlm_transfer(body, opts = {})
      data, _status_code, _headers = xlm_transfer_with_http_info(body, opts)
      data
    end

    # Send XLM / Asset from Tatum ledger to blockchain
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Send XLM or XLM-based Assets from account to account. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If XLM server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def xlm_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.xlm_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.xlm_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/xlm/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#xlm_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create XRP based Asset
    # <h4>2 credits per API call.</h4><br/><p> <p>Create XRP-based Asset in Tatum Ledger. Asset must be created and configured on XRP blockhain before using <a href=\"#operation/XrpTrustLineBlockchain\">Create trust line</a>. This API call will create Tatum internal Virtual Currency. It is possible to create Tatum ledger accounts with off-chain support. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def xrp_asset_offchain(body, opts = {})
      xrp_asset_offchain_with_http_info(body, opts)
      nil
    end

    # Create XRP based Asset
    # &lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Create XRP-based Asset in Tatum Ledger. Asset must be created and configured on XRP blockhain before using &lt;a href&#x3D;\&quot;#operation/XrpTrustLineBlockchain\&quot;&gt;Create trust line&lt;/a&gt;. This API call will create Tatum internal Virtual Currency. It is possible to create Tatum ledger accounts with off-chain support. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def xrp_asset_offchain_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.xrp_asset_offchain ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.xrp_asset_offchain"
      end
      # resource path
      local_var_path = '/v3/offchain/xrp/asset'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#xrp_asset_offchain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Send XRP from Tatum ledger to blockchain
    # <h4>10 credits per API call.</h4><br/><p> <p>Send XRP from account to account. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. <ul> <li>If XRP server connection is unavailable, withdrawal request is cancelled.</li> <li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li> </ul> It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/> This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. </p> 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse20019]
    def xrp_transfer(body, opts = {})
      data, _status_code, _headers = xrp_transfer_with_http_info(body, opts)
      data
    end

    # Send XRP from Tatum ledger to blockchain
    # &lt;h4&gt;10 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt; &lt;p&gt;Send XRP from account to account. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it. &lt;ul&gt; &lt;li&gt;If XRP server connection is unavailable, withdrawal request is cancelled.&lt;/li&gt; &lt;li&gt;If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.&lt;/li&gt; &lt;/ul&gt; It is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.&lt;br/&gt; This operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. &lt;/p&gt; 
    # @param body 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse20019, Integer, Hash)>] InlineResponse20019 data, response status code and response headers
    def xrp_transfer_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: OffChainBlockchainApi.xrp_transfer ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling OffChainBlockchainApi.xrp_transfer"
      end
      # resource path
      local_var_path = '/v3/offchain/xrp/transfer'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'InlineResponse20019' 

      auth_names = opts[:auth_names] || ['X-Api-Key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: OffChainBlockchainApi#xrp_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
